{
  "version": 3,
  "sources": ["../../ol/source/CartoDB.js", "../../ol/source/Cluster.js", "../../ol/source/Zoomify.js", "../../ol/format/IIIFInfo.js", "../../ol/source/IIIF.js", "../../ol/source/Image.js", "../../ol/reproj/Image.js", "../../ol/source/ImageArcGISRest.js", "../../ol/source/ImageCanvas.js", "../../ol/source/ImageMapGuide.js", "../../ol/source/ImageStatic.js", "../../ol/source/ImageWMS.js", "../../ol/source/wms.js", "../../ol/source/Raster.js", "../../ol/source/TileArcGISRest.js", "../../ol/source/TileDebug.js", "../../ol/source/TileWMS.js", "../../ol/source/UTFGrid.js", "../../ol/source.js"],
  "sourcesContent": ["/**\n * @module ol/source/CartoDB\n */\n\nimport XYZ from './XYZ.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [maxZoom=18] Max zoom.\n * @property {number} [minZoom] Minimum zoom.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {Object} [config] If using anonymous maps, the CartoDB config to use. See\n * https://carto.com/developers/maps-api/guides/anonymous-maps/\n * for more detail.\n * If using named maps, a key-value lookup with the template parameters.\n * See https://carto.com/developers/maps-api/guides/named-maps/\n * for more detail.\n * @property {string} [map] If using named maps, this will be the name of the template to load.\n * See https://carto.com/developers/maps-api/guides/named-maps/\n * for more detail.\n * @property {string} [account] Username as used to access public Carto dashboard at https://{username}.carto.com/.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @typedef {Object} CartoDBLayerInfo\n * @property {string} layergroupid The layer group ID\n * @property {{https: string}} cdn_url The CDN URL\n */\n\n/**\n * @classdesc\n * Layer source for the CartoDB Maps API.\n * @api\n */\nclass CartoDB extends XYZ {\n  /**\n   * @param {Options} options CartoDB options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,\n      minZoom: options.minZoom,\n      projection: options.projection,\n      transition: options.transition,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.account_ = options.account;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.mapId_ = options.map || '';\n\n    /**\n     * @type {!Object}\n     * @private\n     */\n    this.config_ = options.config || {};\n\n    /**\n     * @type {!Object<string, CartoDBLayerInfo>}\n     * @private\n     */\n    this.templateCache_ = {};\n\n    this.initializeMap_();\n  }\n\n  /**\n   * Returns the current config.\n   * @return {!Object} The current configuration.\n   * @api\n   */\n  getConfig() {\n    return this.config_;\n  }\n\n  /**\n   * Updates the carto db config.\n   * @param {Object} config a key-value lookup. Values will replace current values\n   *     in the config.\n   * @api\n   */\n  updateConfig(config) {\n    Object.assign(this.config_, config);\n    this.initializeMap_();\n  }\n\n  /**\n   * Sets the CartoDB config\n   * @param {Object} config In the case of anonymous maps, a CartoDB configuration\n   *     object.\n   * If using named maps, a key-value lookup with the template parameters.\n   * @api\n   */\n  setConfig(config) {\n    this.config_ = config || {};\n    this.initializeMap_();\n  }\n\n  /**\n   * Issue a request to initialize the CartoDB map.\n   * @private\n   */\n  initializeMap_() {\n    const paramHash = JSON.stringify(this.config_);\n    if (this.templateCache_[paramHash]) {\n      this.applyTemplate_(this.templateCache_[paramHash]);\n      return;\n    }\n    let mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';\n\n    if (this.mapId_) {\n      mapUrl += '/named/' + this.mapId_;\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener(\n      'load',\n      this.handleInitResponse_.bind(this, paramHash)\n    );\n    client.addEventListener('error', this.handleInitError_.bind(this));\n    client.open('POST', mapUrl);\n    client.setRequestHeader('Content-type', 'application/json');\n    client.send(JSON.stringify(this.config_));\n  }\n\n  /**\n   * Handle map initialization response.\n   * @param {string} paramHash a hash representing the parameter set that was used\n   *     for the request\n   * @param {Event} event Event.\n   * @private\n   */\n  handleInitResponse_(paramHash, event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {CartoDBLayerInfo} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.setState('error');\n        return;\n      }\n      this.applyTemplate_(response);\n      this.templateCache_[paramHash] = response;\n      this.setState('ready');\n    } else {\n      this.setState('error');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event Event.\n   */\n  handleInitError_(event) {\n    this.setState('error');\n  }\n\n  /**\n   * Apply the new tile urls returned by carto db\n   * @param {CartoDBLayerInfo} data Result of carto db call.\n   * @private\n   */\n  applyTemplate_(data) {\n    const tilesUrl =\n      'https://' +\n      data.cdn_url.https +\n      '/' +\n      this.account_ +\n      '/api/v1/map/' +\n      data.layergroupid +\n      '/{z}/{x}/{y}.png';\n    this.setUrl(tilesUrl);\n  }\n}\n\nexport default CartoDB;\n", "/**\n * @module ol/source/Cluster\n */\n\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport {add as addCoordinate, scale as scaleCoordinate} from '../coordinate.js';\nimport {assert} from '../asserts.js';\nimport {\n  buffer,\n  createEmpty,\n  createOrUpdateFromCoordinate,\n  getCenter,\n} from '../extent.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Distance in pixels within which features will\n * be clustered together.\n * @property {number} [minDistance=0] Minimum distance in pixels between clusters.\n * Will be capped at the configured distance.\n * By default no minimum distance is guaranteed. This config can be used to avoid\n * overlapping icons. As a tradoff, the cluster feature's position will no longer be\n * the center of all its features.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature~Feature} as argument and returns an\n * {@link module:ol/geom/Point~Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underlying source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {function(Point, Array<Feature>):Feature} [createCluster]\n * Function that takes the cluster's center {@link module:ol/geom/Point~Point} and an array\n * of {@link module:ol/Feature~Feature} included in this cluster. Must return a\n * {@link module:ol/Feature~Feature} that will be used to render. Default implementation is:\n * ```js\n * function(point, features) {\n *   return new Feature({\n *     geometry: point,\n *     features: features\n *   });\n * }\n * ```\n * @property {VectorSource} [source=null] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\nclass Cluster extends VectorSource {\n  /**\n   * @param {Options} options Cluster options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.resolution = undefined;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.distance = options.distance !== undefined ? options.distance : 20;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.minDistance = options.minDistance || 0;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.interpolationRatio = 0;\n\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n    this.features = [];\n\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n    this.geometryFunction =\n      options.geometryFunction ||\n      function (feature) {\n        const geometry = /** @type {Point} */ (feature.getGeometry());\n        assert(geometry.getType() == 'Point', 10); // The default `geometryFunction` can only handle `Point` geometries\n        return geometry;\n      };\n\n    /**\n     * @type {function(Point, Array<Feature>):Feature}\n     * @private\n     */\n    this.createCustomCluster_ = options.createCluster;\n\n    /**\n     * @type {VectorSource|null}\n     * @protected\n     */\n    this.source = null;\n\n    /**\n     * @private\n     */\n    this.boundRefresh_ = this.refresh.bind(this);\n\n    this.updateDistance(this.distance, this.minDistance);\n    this.setSource(options.source || null);\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.\n   * @api\n   */\n  clear(fast) {\n    this.features.length = 0;\n    super.clear(fast);\n  }\n\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  getDistance() {\n    return this.distance;\n  }\n\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource|null} Source.\n   * @api\n   */\n  getSource() {\n    return this.source;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.resolution = resolution;\n      this.refresh();\n    }\n  }\n\n  /**\n   * Set the distance within which features will be clusterd together.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  setDistance(distance) {\n    this.updateDistance(distance, this.minDistance);\n  }\n\n  /**\n   * Set the minimum distance between clusters. Will be capped at the\n   * configured distance.\n   * @param {number} minDistance The minimum distance in pixels.\n   * @api\n   */\n  setMinDistance(minDistance) {\n    this.updateDistance(this.distance, minDistance);\n  }\n\n  /**\n   * The configured minimum distance between clusters.\n   * @return {number} The minimum distance in pixels.\n   * @api\n   */\n  getMinDistance() {\n    return this.minDistance;\n  }\n\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource|null} source The new source for this instance.\n   * @api\n   */\n  setSource(source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.source = source;\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.refresh();\n  }\n\n  /**\n   * Handle the source changing.\n   */\n  refresh() {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  }\n\n  /**\n   * Update the distances and refresh the source if necessary.\n   * @param {number} distance The new distance.\n   * @param {number} minDistance The new minimum distance.\n   */\n  updateDistance(distance, minDistance) {\n    const ratio =\n      distance === 0 ? 0 : Math.min(minDistance, distance) / distance;\n    const changed =\n      distance !== this.distance || this.interpolationRatio !== ratio;\n    this.distance = distance;\n    this.minDistance = minDistance;\n    this.interpolationRatio = ratio;\n    if (changed) {\n      this.refresh();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  cluster() {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n    const extent = createEmpty();\n    const mapDistance = this.distance * this.resolution;\n    const features = this.source.getFeatures();\n\n    /** @type {Object<string, true>} */\n    const clustered = {};\n\n    for (let i = 0, ii = features.length; i < ii; i++) {\n      const feature = features[i];\n      if (!(getUid(feature) in clustered)) {\n        const geometry = this.geometryFunction(feature);\n        if (geometry) {\n          const coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n\n          const neighbors = this.source\n            .getFeaturesInExtent(extent)\n            .filter(function (neighbor) {\n              const uid = getUid(neighbor);\n              if (uid in clustered) {\n                return false;\n              }\n              clustered[uid] = true;\n              return true;\n            });\n          this.features.push(this.createCluster(neighbors, extent));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Feature>} features Features\n   * @param {import(\"../extent.js\").Extent} extent The searched extent for these features.\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n  createCluster(features, extent) {\n    const centroid = [0, 0];\n    for (let i = features.length - 1; i >= 0; --i) {\n      const geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        addCoordinate(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    scaleCoordinate(centroid, 1 / features.length);\n    const searchCenter = getCenter(extent);\n    const ratio = this.interpolationRatio;\n    const geometry = new Point([\n      centroid[0] * (1 - ratio) + searchCenter[0] * ratio,\n      centroid[1] * (1 - ratio) + searchCenter[1] * ratio,\n    ]);\n    if (this.createCustomCluster_) {\n      return this.createCustomCluster_(geometry, features);\n    } else {\n      return new Feature({\n        geometry,\n        features,\n      });\n    }\n  }\n}\n\nexport default Cluster;\n", "/**\n * @module ol/source/Zoomify\n */\nimport {DEFAULT_TILE_SIZE} from '../tilegrid/common.js';\n\nimport ImageTile from '../ImageTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileImage from './TileImage.js';\nimport TileState from '../TileState.js';\nimport {assert} from '../asserts.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {createFromTileUrlFunctions, expandUrl} from '../tileurlfunction.js';\nimport {getCenter} from '../extent.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {'default' | 'truncated'} TierSizeCalculation\n */\n\nexport class CustomTile extends ImageTile {\n  /**\n   * @param {import(\"../size.js\").Size} tileSize Full tile size.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    tileSize,\n    tileCoord,\n    state,\n    src,\n    crossOrigin,\n    tileLoadFunction,\n    options\n  ) {\n    super(tileCoord, state, src, crossOrigin, tileLoadFunction, options);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}\n     */\n    this.zoomifyImage_ = null;\n\n    /**\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tileSize_ = tileSize;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    if (this.zoomifyImage_) {\n      return this.zoomifyImage_;\n    }\n    const image = super.getImage();\n    if (this.state == TileState.LOADED) {\n      const tileSize = this.tileSize_;\n      if (image.width == tileSize[0] && image.height == tileSize[1]) {\n        this.zoomifyImage_ = image;\n        return image;\n      } else {\n        const context = createCanvasContext2D(tileSize[0], tileSize[1]);\n        context.drawImage(image, 0, 0);\n        this.zoomifyImage_ = context.canvas;\n        return context.canvas;\n      }\n    } else {\n      return image;\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value  you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {number} [tilePixelRatio] The pixel ratio used by the tile service. For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px by 512px images (for retina/hidpi devices) then `tilePixelRatio` should be set to `2`\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {string} url URL template or base URL of the Zoomify service.\n * A base URL is the fixed part\n * of the URL, excluding the tile group, z, x, and y folder structure, e.g.\n * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include\n * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.\n * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.\n * Internet Imaging Protocol (IIP) with JTL extension can be also used with\n * `{tileIndex}` and `{z}` placeholders, e.g.\n * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {TierSizeCalculation} [tierSizeCalculation] Tier size calculation method: `default` or `truncated`.\n * @property {import(\"../size.js\").Size} size Size.\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the TileGrid that is created.\n * Default sets the TileGrid in the\n * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the\n * extent to the first quadrant (the default for OpenLayers 2) set the extent\n * as `[0, 0, width, height]`.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number} [tileSize=256] Tile size. Same tile size is used for all zoom levels.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data in Zoomify format (both Zoomify and Internet\n * Imaging Protocol are supported).\n * @api\n */\nclass Zoomify extends TileImage {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const size = options.size;\n    const tierSizeCalculation =\n      options.tierSizeCalculation !== undefined\n        ? options.tierSizeCalculation\n        : 'default';\n\n    const tilePixelRatio = options.tilePixelRatio || 1;\n    const imageWidth = size[0];\n    const imageHeight = size[1];\n    const tierSizeInTiles = [];\n    const tileSize = options.tileSize || DEFAULT_TILE_SIZE;\n    let tileSizeForTierSizeCalculation = tileSize * tilePixelRatio;\n\n    switch (tierSizeCalculation) {\n      case 'default':\n        while (\n          imageWidth > tileSizeForTierSizeCalculation ||\n          imageHeight > tileSizeForTierSizeCalculation\n        ) {\n          tierSizeInTiles.push([\n            Math.ceil(imageWidth / tileSizeForTierSizeCalculation),\n            Math.ceil(imageHeight / tileSizeForTierSizeCalculation),\n          ]);\n          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;\n        }\n        break;\n      case 'truncated':\n        let width = imageWidth;\n        let height = imageHeight;\n        while (\n          width > tileSizeForTierSizeCalculation ||\n          height > tileSizeForTierSizeCalculation\n        ) {\n          tierSizeInTiles.push([\n            Math.ceil(width / tileSizeForTierSizeCalculation),\n            Math.ceil(height / tileSizeForTierSizeCalculation),\n          ]);\n          width >>= 1;\n          height >>= 1;\n        }\n        break;\n      default: // Unknown `tierSizeCalculation` configured\n        assert(false, 53);\n        break;\n    }\n\n    tierSizeInTiles.push([1, 1]);\n    tierSizeInTiles.reverse();\n\n    const resolutions = [tilePixelRatio];\n    const tileCountUpToTier = [0];\n    for (let i = 1, ii = tierSizeInTiles.length; i < ii; i++) {\n      resolutions.push(tilePixelRatio << i);\n      tileCountUpToTier.push(\n        tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] +\n          tileCountUpToTier[i - 1]\n      );\n    }\n    resolutions.reverse();\n\n    const tileGrid = new TileGrid({\n      tileSize: tileSize,\n      extent: options.extent || [0, -imageHeight, imageWidth, 0],\n      resolutions: resolutions,\n    });\n\n    let url = options.url;\n    if (url && !url.includes('{TileGroup}') && !url.includes('{tileIndex}')) {\n      url += '{TileGroup}/{z}-{x}-{y}.jpg';\n    }\n    const urls = expandUrl(url);\n\n    let tileWidth = tileSize * tilePixelRatio;\n\n    /**\n     * @param {string} template Template.\n     * @return {import(\"../Tile.js\").UrlFunction} Tile URL function.\n     */\n    function createFromTemplate(template) {\n      return (\n        /**\n         * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n         * @param {number} pixelRatio Pixel ratio.\n         * @param {import(\"../proj/Projection.js\").default} projection Projection.\n         * @return {string|undefined} Tile URL.\n         */\n        function (tileCoord, pixelRatio, projection) {\n          if (!tileCoord) {\n            return undefined;\n          } else {\n            const tileCoordZ = tileCoord[0];\n            const tileCoordX = tileCoord[1];\n            const tileCoordY = tileCoord[2];\n            const tileIndex =\n              tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];\n            const tileGroup =\n              ((tileIndex + tileCountUpToTier[tileCoordZ]) / tileWidth) | 0;\n            const localContext = {\n              'z': tileCoordZ,\n              'x': tileCoordX,\n              'y': tileCoordY,\n              'tileIndex': tileIndex,\n              'TileGroup': 'TileGroup' + tileGroup,\n            };\n            return template.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n              return localContext[p];\n            });\n          }\n        }\n      );\n    }\n\n    const tileUrlFunction = createFromTileUrlFunctions(\n      urls.map(createFromTemplate)\n    );\n\n    const ZoomifyTileClass = CustomTile.bind(\n      null,\n      toSize(tileSize * tilePixelRatio)\n    );\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      tilePixelRatio: tilePixelRatio,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: ZoomifyTileClass,\n      tileGrid: tileGrid,\n      tileUrlFunction: tileUrlFunction,\n      transition: options.transition,\n    });\n\n    /**\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection;\n\n    // Server retina tile detection (non-standard):\n    // Try loading the center tile for the highest resolution. If it is not\n    // available, we are dealing with retina tiles, and need to adjust the\n    // tile url calculation.\n    const tileUrl = tileGrid.getTileCoordForCoordAndResolution(\n      getCenter(tileGrid.getExtent()),\n      resolutions[resolutions.length - 1]\n    );\n    const testTileUrl = tileUrlFunction(tileUrl, 1, null);\n    const image = new Image();\n    image.addEventListener(\n      'error',\n      function () {\n        tileWidth = tileSize;\n        this.changed();\n      }.bind(this)\n    );\n    image.src = testTileUrl;\n  }\n}\n\nexport default Zoomify;\n", "/**\n * @module ol/format/IIIFInfo\n */\n\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} PreferredOptions\n * @property {string} [format] Preferred image format. Will be used if the image information\n * indicates support for that format.\n * @property {string} [quality] IIIF image qualitiy.  Will be used if the image information\n * indicates support for that quality.\n */\n\n/**\n * @typedef {Object} SupportedFeatures\n * @property {Array<string>} [supports] Supported IIIF image size and region\n * calculation features.\n * @property {Array<string>} [formats] Supported image formats.\n * @property {Array<string>} [qualities] Supported IIIF image qualities.\n */\n\n/**\n * @typedef {Object} TileInfo\n * @property {Array<number>} scaleFactors Supported resolution scaling factors.\n * @property {number} width Tile width in pixels.\n * @property {number} [height] Tile height in pixels. Same as tile width if height is\n * not given.\n */\n\n/**\n * @typedef {Object} IiifProfile\n * @property {Array<string>} [formats] Supported image formats for the image service.\n * @property {Array<string>} [qualities] Supported IIIF image qualities.\n * @property {Array<string>} [supports] Supported features.\n * @property {number} [maxArea] Maximum area (pixels) available for this image service.\n * @property {number} [maxHeight] Maximum height.\n * @property {number} [maxWidth] Maximum width.\n */\n\n/**\n * @typedef {Object<string,string|number|Array<number|string|IiifProfile|Object<string, number>|TileInfo>>}\n *    ImageInformationResponse\n */\n\n/**\n * Enum representing the major IIIF Image API versions\n * @enum {string}\n */\nexport const Versions = {\n  VERSION1: 'version1',\n  VERSION2: 'version2',\n  VERSION3: 'version3',\n};\n\n/**\n * Supported image formats, qualities and supported region / size calculation features\n * for different image API versions and compliance levels\n * @const\n * @type {Object<string, Object<string, SupportedFeatures>>}\n */\nconst IIIF_PROFILE_VALUES = {};\nIIIF_PROFILE_VALUES[Versions.VERSION1] = {\n  'level0': {\n    supports: [],\n    formats: [],\n    qualities: ['native'],\n  },\n  'level1': {\n    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],\n    formats: ['jpg'],\n    qualities: ['native'],\n  },\n  'level2': {\n    supports: [\n      'regionByPx',\n      'regionByPct',\n      'sizeByW',\n      'sizeByH',\n      'sizeByPct',\n      'sizeByConfinedWh',\n      'sizeByWh',\n    ],\n    formats: ['jpg', 'png'],\n    qualities: ['native', 'color', 'grey', 'bitonal'],\n  },\n};\nIIIF_PROFILE_VALUES[Versions.VERSION2] = {\n  'level0': {\n    supports: [],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level1': {\n    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level2': {\n    supports: [\n      'regionByPx',\n      'regionByPct',\n      'sizeByW',\n      'sizeByH',\n      'sizeByPct',\n      'sizeByConfinedWh',\n      'sizeByDistortedWh',\n      'sizeByWh',\n    ],\n    formats: ['jpg', 'png'],\n    qualities: ['default', 'bitonal'],\n  },\n};\nIIIF_PROFILE_VALUES[Versions.VERSION3] = {\n  'level0': {\n    supports: [],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level1': {\n    supports: ['regionByPx', 'regionSquare', 'sizeByW', 'sizeByH', 'sizeByWh'],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level2': {\n    supports: [\n      'regionByPx',\n      'regionSquare',\n      'regionByPct',\n      'sizeByW',\n      'sizeByH',\n      'sizeByPct',\n      'sizeByConfinedWh',\n      'sizeByWh',\n    ],\n    formats: ['jpg', 'png'],\n    qualities: ['default'],\n  },\n};\nIIIF_PROFILE_VALUES['none'] = {\n  'none': {\n    supports: [],\n    formats: [],\n    qualities: [],\n  },\n};\n\nconst COMPLIANCE_VERSION1 =\n  /^https?:\\/\\/library\\.stanford\\.edu\\/iiif\\/image-api\\/(?:1\\.1\\/)?compliance\\.html#level[0-2]$/;\nconst COMPLIANCE_VERSION2 =\n  /^https?:\\/\\/iiif\\.io\\/api\\/image\\/2\\/level[0-2](?:\\.json)?$/;\nconst COMPLIANCE_VERSION3 =\n  /(^https?:\\/\\/iiif\\.io\\/api\\/image\\/3\\/level[0-2](?:\\.json)?$)|(^level[0-2]$)/;\n\nfunction generateVersion1Options(iiifInfo) {\n  let levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();\n  // Version 1.0 and 1.1 do not require a profile.\n  if (levelProfile === undefined) {\n    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]['level0'];\n  }\n  return {\n    url:\n      iiifInfo.imageInfo['@id'] === undefined\n        ? undefined\n        : iiifInfo.imageInfo['@id'].replace(/\\/?(?:info\\.json)?$/g, ''),\n    supports: levelProfile.supports,\n    formats: [\n      ...levelProfile.formats,\n      iiifInfo.imageInfo.formats === undefined\n        ? []\n        : iiifInfo.imageInfo.formats,\n    ],\n    qualities: [\n      ...levelProfile.qualities,\n      iiifInfo.imageInfo.qualities === undefined\n        ? []\n        : iiifInfo.imageInfo.qualities,\n    ],\n    resolutions: iiifInfo.imageInfo.scale_factors,\n    tileSize:\n      iiifInfo.imageInfo.tile_width !== undefined\n        ? iiifInfo.imageInfo.tile_height !== undefined\n          ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height]\n          : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width]\n        : iiifInfo.imageInfo.tile_height != undefined\n        ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height]\n        : undefined,\n  };\n}\n\nfunction generateVersion2Options(iiifInfo) {\n  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),\n    additionalProfile =\n      Array.isArray(iiifInfo.imageInfo.profile) &&\n      iiifInfo.imageInfo.profile.length > 1,\n    profileSupports =\n      additionalProfile && iiifInfo.imageInfo.profile[1].supports\n        ? iiifInfo.imageInfo.profile[1].supports\n        : [],\n    profileFormats =\n      additionalProfile && iiifInfo.imageInfo.profile[1].formats\n        ? iiifInfo.imageInfo.profile[1].formats\n        : [],\n    profileQualities =\n      additionalProfile && iiifInfo.imageInfo.profile[1].qualities\n        ? iiifInfo.imageInfo.profile[1].qualities\n        : [];\n  return {\n    url: iiifInfo.imageInfo['@id'].replace(/\\/?(?:info\\.json)?$/g, ''),\n    sizes:\n      iiifInfo.imageInfo.sizes === undefined\n        ? undefined\n        : iiifInfo.imageInfo.sizes.map(function (size) {\n            return [size.width, size.height];\n          }),\n    tileSize:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : [\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.width;\n            })[0],\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.height === undefined ? tile.width : tile.height;\n            })[0],\n          ],\n    resolutions:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : iiifInfo.imageInfo.tiles.map(function (tile) {\n            return tile.scaleFactors;\n          })[0],\n    supports: [...levelProfile.supports, ...profileSupports],\n    formats: [...levelProfile.formats, ...profileFormats],\n    qualities: [...levelProfile.qualities, ...profileQualities],\n  };\n}\n\nfunction generateVersion3Options(iiifInfo) {\n  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),\n    formats =\n      iiifInfo.imageInfo.extraFormats === undefined\n        ? levelProfile.formats\n        : [...levelProfile.formats, ...iiifInfo.imageInfo.extraFormats],\n    preferredFormat =\n      iiifInfo.imageInfo.preferredFormats !== undefined &&\n      Array.isArray(iiifInfo.imageInfo.preferredFormats) &&\n      iiifInfo.imageInfo.preferredFormats.length > 0\n        ? iiifInfo.imageInfo.preferredFormats\n            .filter(function (format) {\n              return ['jpg', 'png', 'gif'].includes(format);\n            })\n            .reduce(function (acc, format) {\n              return acc === undefined && formats.includes(format)\n                ? format\n                : acc;\n            }, undefined)\n        : undefined;\n  return {\n    url: iiifInfo.imageInfo['id'],\n    sizes:\n      iiifInfo.imageInfo.sizes === undefined\n        ? undefined\n        : iiifInfo.imageInfo.sizes.map(function (size) {\n            return [size.width, size.height];\n          }),\n    tileSize:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : [\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.width;\n            })[0],\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.height;\n            })[0],\n          ],\n    resolutions:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : iiifInfo.imageInfo.tiles.map(function (tile) {\n            return tile.scaleFactors;\n          })[0],\n    supports:\n      iiifInfo.imageInfo.extraFeatures === undefined\n        ? levelProfile.supports\n        : [...levelProfile.supports, ...iiifInfo.imageInfo.extraFeatures],\n    formats: formats,\n    qualities:\n      iiifInfo.imageInfo.extraQualities === undefined\n        ? levelProfile.qualities\n        : [...levelProfile.qualities, ...iiifInfo.imageInfo.extraQualities],\n    preferredFormat: preferredFormat,\n  };\n}\n\nconst versionFunctions = {};\nversionFunctions[Versions.VERSION1] = generateVersion1Options;\nversionFunctions[Versions.VERSION2] = generateVersion2Options;\nversionFunctions[Versions.VERSION3] = generateVersion3Options;\n\n/**\n * @classdesc\n * Format for transforming IIIF Image API image information responses into\n * IIIF tile source ready options\n *\n * @api\n */\nclass IIIFInfo {\n  /**\n   * @param {string|ImageInformationResponse} imageInfo\n   * Deserialized image information JSON response object or JSON response as string\n   */\n  constructor(imageInfo) {\n    this.setImageInfo(imageInfo);\n  }\n\n  /**\n   * @param {string|ImageInformationResponse} imageInfo\n   * Deserialized image information JSON response object or JSON response as string\n   * @api\n   */\n  setImageInfo(imageInfo) {\n    if (typeof imageInfo == 'string') {\n      this.imageInfo = JSON.parse(imageInfo);\n    } else {\n      this.imageInfo = imageInfo;\n    }\n  }\n\n  /**\n   * @return {Versions} Major IIIF version.\n   * @api\n   */\n  getImageApiVersion() {\n    if (this.imageInfo === undefined) {\n      return;\n    }\n    let context = this.imageInfo['@context'] || 'ol-no-context';\n    if (typeof context == 'string') {\n      context = [context];\n    }\n    for (let i = 0; i < context.length; i++) {\n      switch (context[i]) {\n        case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':\n        case 'http://iiif.io/api/image/1/context.json':\n          return Versions.VERSION1;\n        case 'http://iiif.io/api/image/2/context.json':\n          return Versions.VERSION2;\n        case 'http://iiif.io/api/image/3/context.json':\n          return Versions.VERSION3;\n        case 'ol-no-context':\n          // Image API 1.0 has no '@context'\n          if (\n            this.getComplianceLevelEntryFromProfile(Versions.VERSION1) &&\n            this.imageInfo.identifier\n          ) {\n            return Versions.VERSION1;\n          }\n          break;\n        default:\n      }\n    }\n    assert(false, 61);\n  }\n\n  /**\n   * @param {Versions} version Optional IIIF image API version\n   * @return {string} Compliance level as it appears in the IIIF image information\n   * response.\n   */\n  getComplianceLevelEntryFromProfile(version) {\n    if (this.imageInfo === undefined || this.imageInfo.profile === undefined) {\n      return;\n    }\n    if (version === undefined) {\n      version = this.getImageApiVersion();\n    }\n    switch (version) {\n      case Versions.VERSION1:\n        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {\n          return this.imageInfo.profile;\n        }\n        break;\n      case Versions.VERSION3:\n        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {\n          return this.imageInfo.profile;\n        }\n        break;\n      case Versions.VERSION2:\n        if (\n          typeof this.imageInfo.profile === 'string' &&\n          COMPLIANCE_VERSION2.test(this.imageInfo.profile)\n        ) {\n          return this.imageInfo.profile;\n        }\n        if (\n          Array.isArray(this.imageInfo.profile) &&\n          this.imageInfo.profile.length > 0 &&\n          typeof this.imageInfo.profile[0] === 'string' &&\n          COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])\n        ) {\n          return this.imageInfo.profile[0];\n        }\n        break;\n      default:\n    }\n  }\n\n  /**\n   * @param {Versions} version Optional IIIF image API version\n   * @return {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined\n   */\n  getComplianceLevelFromProfile(version) {\n    const complianceLevel = this.getComplianceLevelEntryFromProfile(version);\n    if (complianceLevel === undefined) {\n      return undefined;\n    }\n    const level = complianceLevel.match(/level[0-2](?:\\.json)?$/g);\n    return Array.isArray(level) ? level[0].replace('.json', '') : undefined;\n  }\n\n  /**\n   * @return {SupportedFeatures} Image formats, qualities and region / size calculation\n   * methods that are supported by the IIIF service.\n   */\n  getComplianceLevelSupportedFeatures() {\n    if (this.imageInfo === undefined) {\n      return;\n    }\n    const version = this.getImageApiVersion();\n    const level = this.getComplianceLevelFromProfile(version);\n    if (level === undefined) {\n      return IIIF_PROFILE_VALUES['none']['none'];\n    }\n    return IIIF_PROFILE_VALUES[version][level];\n  }\n\n  /**\n   * @param {PreferredOptions} [preferredOptions] Optional options for preferred format and quality.\n   * @return {import(\"../source/IIIF.js\").Options} IIIF tile source ready constructor options.\n   * @api\n   */\n  getTileSourceOptions(preferredOptions) {\n    const options = preferredOptions || {},\n      version = this.getImageApiVersion();\n    if (version === undefined) {\n      return;\n    }\n    const imageOptions =\n      version === undefined ? undefined : versionFunctions[version](this);\n    if (imageOptions === undefined) {\n      return;\n    }\n    return {\n      url: imageOptions.url,\n      version: version,\n      size: [this.imageInfo.width, this.imageInfo.height],\n      sizes: imageOptions.sizes,\n      format:\n        options.format !== undefined &&\n        imageOptions.formats.includes(options.format)\n          ? options.format\n          : imageOptions.preferredFormat !== undefined\n          ? imageOptions.preferredFormat\n          : 'jpg',\n      supports: imageOptions.supports,\n      quality:\n        options.quality && imageOptions.qualities.includes(options.quality)\n          ? options.quality\n          : imageOptions.qualities.includes('native')\n          ? 'native'\n          : 'default',\n      resolutions: Array.isArray(imageOptions.resolutions)\n        ? imageOptions.resolutions.sort(function (a, b) {\n            return b - a;\n          })\n        : undefined,\n      tileSize: imageOptions.tileSize,\n    };\n  }\n}\n\nexport default IIIFInfo;\n", "/**\n * @module ol/source/IIIF\n */\n\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileImage from './TileImage.js';\nimport {CustomTile} from './Zoomify.js';\nimport {DEFAULT_TILE_SIZE} from '../tilegrid/common.js';\nimport {Versions} from '../format/IIIFInfo.js';\nimport {assert} from '../asserts.js';\nimport {getTopLeft} from '../extent.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Size of the cache.\n * @property {null|string} [crossOrigin] The value for the crossOrigin option of the request.\n * @property {import(\"../extent.js\").Extent} [extent=[0, -height, width, 0]] The extent.\n * @property {string} [format='jpg'] Requested image format.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {string} [quality] Requested IIIF image quality. Default is 'native'\n * for version 1, 'default' for versions 2 and 3.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Array<number>} [resolutions] Supported resolutions as given in IIIF 'scaleFactors'\n * @property {import(\"../size.js\").Size} size Size of the image [width, height].\n * @property {Array<import(\"../size.js\").Size>} [sizes] Supported scaled image sizes.\n * Content of the IIIF info.json 'sizes' property, but as array of Size objects.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {Array<string>} [supports=[]] Supported IIIF region and size calculation\n * features.\n * @property {number} [tilePixelRatio] Tile pixel ratio.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Same tile size is used for all zoom levels. If tile size is a number,\n * a square tile is assumed. If the IIIF image service supports arbitrary\n * tiling (sizeByH, sizeByW, sizeByWh or sizeByPct as well as regionByPx or regionByPct\n * are supported), the default tilesize is 256.\n * @property {number} [transition] Transition.\n * @property {string} [url] Base URL of the IIIF Image service.\n * This should be the same as the IIIF Image ID.\n * @property {import(\"../format/IIIFInfo.js\").Versions} [version=Versions.VERSION2] Service's IIIF Image API version.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\nfunction formatPercentage(percentage) {\n  return percentage.toLocaleString('en', {maximumFractionDigits: 10});\n}\n\n/**\n * @classdesc\n * Layer source for IIIF Image API services.\n * @api\n */\nclass IIIF extends TileImage {\n  /**\n   * @param {Options} [options] Tile source options. Use {@link import(\"../format/IIIFInfo.js\").IIIFInfo}\n   * to parse Image API service information responses into constructor options.\n   * @api\n   */\n  constructor(options) {\n    /**\n     * @type {Partial<Options>}\n     */\n    const partialOptions = options || {};\n\n    let baseUrl = partialOptions.url || '';\n    baseUrl =\n      baseUrl +\n      (baseUrl.lastIndexOf('/') === baseUrl.length - 1 || baseUrl === ''\n        ? ''\n        : '/');\n    const version = partialOptions.version || Versions.VERSION2;\n    const sizes = partialOptions.sizes || [];\n    const size = partialOptions.size;\n    assert(\n      size != undefined &&\n        Array.isArray(size) &&\n        size.length == 2 &&\n        !isNaN(size[0]) &&\n        size[0] > 0 &&\n        !isNaN(size[1]) &&\n        size[1] > 0,\n      60\n    );\n    const width = size[0];\n    const height = size[1];\n    const tileSize = partialOptions.tileSize;\n    const tilePixelRatio = partialOptions.tilePixelRatio || 1;\n    const format = partialOptions.format || 'jpg';\n    const quality =\n      partialOptions.quality ||\n      (partialOptions.version == Versions.VERSION1 ? 'native' : 'default');\n    let resolutions = partialOptions.resolutions || [];\n    const supports = partialOptions.supports || [];\n    const extent = partialOptions.extent || [0, -height, width, 0];\n\n    const supportsListedSizes =\n      sizes != undefined && Array.isArray(sizes) && sizes.length > 0;\n    const supportsListedTiles =\n      tileSize !== undefined &&\n      ((typeof tileSize === 'number' &&\n        Number.isInteger(tileSize) &&\n        tileSize > 0) ||\n        (Array.isArray(tileSize) && tileSize.length > 0));\n    const supportsArbitraryTiling =\n      supports != undefined &&\n      Array.isArray(supports) &&\n      (supports.includes('regionByPx') || supports.includes('regionByPct')) &&\n      (supports.includes('sizeByWh') ||\n        supports.includes('sizeByH') ||\n        supports.includes('sizeByW') ||\n        supports.includes('sizeByPct'));\n\n    let tileWidth, tileHeight, maxZoom;\n\n    resolutions.sort(function (a, b) {\n      return b - a;\n    });\n\n    if (supportsListedTiles || supportsArbitraryTiling) {\n      if (tileSize != undefined) {\n        if (\n          typeof tileSize === 'number' &&\n          Number.isInteger(tileSize) &&\n          tileSize > 0\n        ) {\n          tileWidth = tileSize;\n          tileHeight = tileSize;\n        } else if (Array.isArray(tileSize) && tileSize.length > 0) {\n          if (\n            tileSize.length == 1 ||\n            (tileSize[1] == undefined && Number.isInteger(tileSize[0]))\n          ) {\n            tileWidth = tileSize[0];\n            tileHeight = tileSize[0];\n          }\n          if (tileSize.length == 2) {\n            if (\n              Number.isInteger(tileSize[0]) &&\n              Number.isInteger(tileSize[1])\n            ) {\n              tileWidth = tileSize[0];\n              tileHeight = tileSize[1];\n            } else if (\n              tileSize[0] == undefined &&\n              Number.isInteger(tileSize[1])\n            ) {\n              tileWidth = tileSize[1];\n              tileHeight = tileSize[1];\n            }\n          }\n        }\n      }\n      if (tileWidth === undefined || tileHeight === undefined) {\n        tileWidth = DEFAULT_TILE_SIZE;\n        tileHeight = DEFAULT_TILE_SIZE;\n      }\n      if (resolutions.length == 0) {\n        maxZoom = Math.max(\n          Math.ceil(Math.log(width / tileWidth) / Math.LN2),\n          Math.ceil(Math.log(height / tileHeight) / Math.LN2)\n        );\n        for (let i = maxZoom; i >= 0; i--) {\n          resolutions.push(Math.pow(2, i));\n        }\n      } else {\n        const maxScaleFactor = Math.max(...resolutions);\n        // TODO maxScaleFactor might not be a power to 2\n        maxZoom = Math.round(Math.log(maxScaleFactor) / Math.LN2);\n      }\n    } else {\n      // No tile support.\n      tileWidth = width;\n      tileHeight = height;\n      resolutions = [];\n      if (supportsListedSizes) {\n        /*\n         * 'sizes' provided. Use full region in different resolutions. Every\n         * resolution has only one tile.\n         */\n        sizes.sort(function (a, b) {\n          return a[0] - b[0];\n        });\n        maxZoom = -1;\n        const ignoredSizesIndex = [];\n        for (let i = 0; i < sizes.length; i++) {\n          const resolution = width / sizes[i][0];\n          if (\n            resolutions.length > 0 &&\n            resolutions[resolutions.length - 1] == resolution\n          ) {\n            ignoredSizesIndex.push(i);\n            continue;\n          }\n          resolutions.push(resolution);\n          maxZoom++;\n        }\n        if (ignoredSizesIndex.length > 0) {\n          for (let i = 0; i < ignoredSizesIndex.length; i++) {\n            sizes.splice(ignoredSizesIndex[i] - i, 1);\n          }\n        }\n      } else {\n        // No useful image information at all. Try pseudo tile with full image.\n        resolutions.push(1);\n        sizes.push([width, height]);\n        maxZoom = 0;\n      }\n    }\n\n    const tileGrid = new TileGrid({\n      tileSize: [tileWidth, tileHeight],\n      extent: extent,\n      origin: getTopLeft(extent),\n      resolutions: resolutions,\n    });\n\n    const tileUrlFunction = function (tileCoord, pixelRatio, projection) {\n      let regionParam, sizeParam;\n      const zoom = tileCoord[0];\n      if (zoom > maxZoom) {\n        return;\n      }\n      const tileX = tileCoord[1],\n        tileY = tileCoord[2],\n        scale = resolutions[zoom];\n      if (\n        tileX === undefined ||\n        tileY === undefined ||\n        scale === undefined ||\n        tileX < 0 ||\n        Math.ceil(width / scale / tileWidth) <= tileX ||\n        tileY < 0 ||\n        Math.ceil(height / scale / tileHeight) <= tileY\n      ) {\n        return;\n      }\n      if (supportsArbitraryTiling || supportsListedTiles) {\n        const regionX = tileX * tileWidth * scale,\n          regionY = tileY * tileHeight * scale;\n        let regionW = tileWidth * scale,\n          regionH = tileHeight * scale,\n          sizeW = tileWidth,\n          sizeH = tileHeight;\n        if (regionX + regionW > width) {\n          regionW = width - regionX;\n        }\n        if (regionY + regionH > height) {\n          regionH = height - regionY;\n        }\n        if (regionX + tileWidth * scale > width) {\n          sizeW = Math.floor((width - regionX + scale - 1) / scale);\n        }\n        if (regionY + tileHeight * scale > height) {\n          sizeH = Math.floor((height - regionY + scale - 1) / scale);\n        }\n        if (\n          regionX == 0 &&\n          regionW == width &&\n          regionY == 0 &&\n          regionH == height\n        ) {\n          // canonical full image region parameter is 'full', not 'x,y,w,h'\n          regionParam = 'full';\n        } else if (\n          !supportsArbitraryTiling ||\n          supports.includes('regionByPx')\n        ) {\n          regionParam = regionX + ',' + regionY + ',' + regionW + ',' + regionH;\n        } else if (supports.includes('regionByPct')) {\n          const pctX = formatPercentage((regionX / width) * 100),\n            pctY = formatPercentage((regionY / height) * 100),\n            pctW = formatPercentage((regionW / width) * 100),\n            pctH = formatPercentage((regionH / height) * 100);\n          regionParam = 'pct:' + pctX + ',' + pctY + ',' + pctW + ',' + pctH;\n        }\n        if (\n          version == Versions.VERSION3 &&\n          (!supportsArbitraryTiling || supports.includes('sizeByWh'))\n        ) {\n          sizeParam = sizeW + ',' + sizeH;\n        } else if (!supportsArbitraryTiling || supports.includes('sizeByW')) {\n          sizeParam = sizeW + ',';\n        } else if (supports.includes('sizeByH')) {\n          sizeParam = ',' + sizeH;\n        } else if (supports.includes('sizeByWh')) {\n          sizeParam = sizeW + ',' + sizeH;\n        } else if (supports.includes('sizeByPct')) {\n          sizeParam = 'pct:' + formatPercentage(100 / scale);\n        }\n      } else {\n        regionParam = 'full';\n        if (supportsListedSizes) {\n          const regionWidth = sizes[zoom][0],\n            regionHeight = sizes[zoom][1];\n          if (version == Versions.VERSION3) {\n            if (regionWidth == width && regionHeight == height) {\n              sizeParam = 'max';\n            } else {\n              sizeParam = regionWidth + ',' + regionHeight;\n            }\n          } else {\n            if (regionWidth == width) {\n              sizeParam = 'full';\n            } else {\n              sizeParam = regionWidth + ',';\n            }\n          }\n        } else {\n          sizeParam = version == Versions.VERSION3 ? 'max' : 'full';\n        }\n      }\n      return (\n        baseUrl + regionParam + '/' + sizeParam + '/0/' + quality + '.' + format\n      );\n    };\n\n    const IiifTileClass = CustomTile.bind(\n      null,\n      toSize(tileSize || 256).map(function (size) {\n        return size * tilePixelRatio;\n      })\n    );\n\n    super({\n      attributions: partialOptions.attributions,\n      attributionsCollapsible: partialOptions.attributionsCollapsible,\n      cacheSize: partialOptions.cacheSize,\n      crossOrigin: partialOptions.crossOrigin,\n      interpolate: partialOptions.interpolate,\n      projection: partialOptions.projection,\n      reprojectionErrorThreshold: partialOptions.reprojectionErrorThreshold,\n      state: partialOptions.state,\n      tileClass: IiifTileClass,\n      tileGrid: tileGrid,\n      tilePixelRatio: partialOptions.tilePixelRatio,\n      tileUrlFunction: tileUrlFunction,\n      transition: partialOptions.transition,\n    });\n\n    /**\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = partialOptions.zDirection;\n  }\n}\n\nexport default IIIF;\n", "/**\n * @module ol/source/Image\n */\nimport Event from '../events/Event.js';\nimport ImageState from '../ImageState.js';\nimport ReprojImage from '../reproj/Image.js';\nimport Source from './Source.js';\nimport {abstract} from '../util.js';\nimport {equals} from '../extent.js';\nimport {equivalent} from '../proj.js';\nimport {linearFindNearest} from '../array.js';\n\n/**\n * @enum {string}\n */\nexport const ImageSourceEventType = {\n  /**\n   * Triggered when an image starts loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart\n   * @api\n   */\n  IMAGELOADSTART: 'imageloadstart',\n\n  /**\n   * Triggered when an image finishes loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadend\n   * @api\n   */\n  IMAGELOADEND: 'imageloadend',\n\n  /**\n   * Triggered if image loading results in an error.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror\n   * @api\n   */\n  IMAGELOADERROR: 'imageloaderror',\n};\n\n/**\n * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this\n * type.\n */\nexport class ImageSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Image.js\").default} image The image.\n   */\n  constructor(type, image) {\n    super(type);\n\n    /**\n     * The image related to the event.\n     * @type {import(\"../Image.js\").default}\n     * @api\n     */\n    this.image = image;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {Array<number>} [resolutions] Resolutions.\n * @property {import(\"./Source.js\").State} [state] State.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing a single image.\n * @abstract\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageSource extends Source {\n  /**\n   * @param {Options} options Single image source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      projection: options.projection,\n      state: options.state,\n      interpolate:\n        options.interpolate !== undefined ? options.interpolate : true,\n    });\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ImageSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.resolutions_ =\n      options.resolutions !== undefined ? options.resolutions : null;\n\n    /**\n     * @private\n     * @type {import(\"../reproj/Image.js\").default}\n     */\n    this.reprojectedImage_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.reprojectedRevision_ = 0;\n  }\n\n  /**\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @protected\n   * @param {number} resolution Resolution.\n   * @return {number} Resolution.\n   */\n  findNearestResolution(resolution) {\n    if (this.resolutions_) {\n      const idx = linearFindNearest(this.resolutions_, resolution, 0);\n      resolution = this.resolutions_[idx];\n    }\n    return resolution;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageBase.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n      return this.getImageInternal(extent, resolution, pixelRatio, projection);\n    } else {\n      if (this.reprojectedImage_) {\n        if (\n          this.reprojectedRevision_ == this.getRevision() &&\n          equivalent(this.reprojectedImage_.getProjection(), projection) &&\n          this.reprojectedImage_.getResolution() == resolution &&\n          equals(this.reprojectedImage_.getExtent(), extent)\n        ) {\n          return this.reprojectedImage_;\n        }\n        this.reprojectedImage_.dispose();\n        this.reprojectedImage_ = null;\n      }\n\n      this.reprojectedImage_ = new ReprojImage(\n        sourceProjection,\n        projection,\n        extent,\n        resolution,\n        pixelRatio,\n        function (extent, resolution, pixelRatio) {\n          return this.getImageInternal(\n            extent,\n            resolution,\n            pixelRatio,\n            sourceProjection\n          );\n        }.bind(this),\n        this.getInterpolate()\n      );\n      this.reprojectedRevision_ = this.getRevision();\n\n      return this.reprojectedImage_;\n    }\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageBase.js\").default} Single image.\n   * @protected\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Handle image change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleImageChange(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    let type;\n    switch (image.getState()) {\n      case ImageState.LOADING:\n        this.loading = true;\n        type = ImageSourceEventType.IMAGELOADSTART;\n        break;\n      case ImageState.LOADED:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADEND;\n        break;\n      case ImageState.ERROR:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADERROR;\n        break;\n      default:\n        return;\n    }\n    if (this.hasListener(type)) {\n      this.dispatchEvent(new ImageSourceEvent(type, image));\n    }\n  }\n}\n\n/**\n * Default image load function for image sources that use import(\"../Image.js\").Image image\n * instances.\n * @param {import(\"../Image.js\").default} image Image.\n * @param {string} src Source.\n */\nexport function defaultImageLoadFunction(image, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;\n}\n\nexport default ImageSource;\n", "/**\n * @module ol/reproj/Image\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport ImageBase from '../ImageBase.js';\nimport ImageState from '../ImageState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {getCenter, getHeight, getIntersection, getWidth} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../ImageBase.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected image.\n * See {@link module:ol/source/Image~ImageSource}.\n */\nclass ReprojImage extends ImageBase {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection (of the data).\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent.\n   * @param {number} targetResolution Target resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {FunctionType} getImageFunction\n   *     Function returning source images (extent, resolution, pixelRatio).\n   * @param {boolean} interpolate Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    targetResolution,\n    pixelRatio,\n    getImageFunction,\n    interpolate\n  ) {\n    const maxSourceExtent = sourceProj.getExtent();\n    const maxTargetExtent = targetProj.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    const targetCenter = getCenter(limitedTargetExtent);\n    const sourceResolution = calculateSourceResolution(\n      sourceProj,\n      targetProj,\n      targetCenter,\n      targetResolution\n    );\n\n    const errorThresholdInPixels = ERROR_THRESHOLD;\n\n    const triangulation = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    const sourceExtent = triangulation.calculateSourceExtent();\n    const sourceImage = getImageFunction(\n      sourceExtent,\n      sourceResolution,\n      pixelRatio\n    );\n    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\n    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\n\n    super(targetExtent, targetResolution, sourcePixelRatio, state);\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.targetProj_ = targetProj;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = triangulation;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.targetResolution_ = targetResolution;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.targetExtent_ = targetExtent;\n\n    /**\n     * @private\n     * @type {import(\"../ImageBase.js\").default}\n     */\n    this.sourceImage_ = sourceImage;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourcePixelRatio_ = sourcePixelRatio;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = interpolate;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceListenerKey_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state == ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n    super.disposeInternal();\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  getProjection() {\n    return this.targetProj_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sourceState = this.sourceImage_.getState();\n    if (sourceState == ImageState.LOADED) {\n      const width = getWidth(this.targetExtent_) / this.targetResolution_;\n      const height = getHeight(this.targetExtent_) / this.targetResolution_;\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.sourcePixelRatio_,\n        this.sourceImage_.getResolution(),\n        this.maxSourceExtent_,\n        this.targetResolution_,\n        this.targetExtent_,\n        this.triangulation_,\n        [\n          {\n            extent: this.sourceImage_.getExtent(),\n            image: this.sourceImage_.getImage(),\n          },\n        ],\n        0,\n        undefined,\n        this.interpolate_\n      );\n    }\n    this.state = sourceState;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n\n      const sourceState = this.sourceImage_.getState();\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = listen(\n          this.sourceImage_,\n          EventType.CHANGE,\n          function (e) {\n            const sourceState = this.sourceImage_.getState();\n            if (\n              sourceState == ImageState.LOADED ||\n              sourceState == ImageState.ERROR\n            ) {\n              this.unlistenSource_();\n              this.reproject_();\n            }\n          },\n          this\n        );\n        this.sourceImage_.load();\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSource_() {\n    unlistenByKey(\n      /** @type {!import(\"../events.js\").EventsKey} */ (this.sourceListenerKey_)\n    );\n    this.sourceListenerKey_ = null;\n  }\n}\n\nexport default ReprojImage;\n", "/**\n * @module ol/source/ImageArcGISRest\n */\n\nimport EventType from '../events/EventType.js';\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport ImageWrapper from '../Image.js';\nimport {appendParams} from '../uri.js';\nimport {assert} from '../asserts.js';\nimport {containsExtent, getHeight, getWidth} from '../extent.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from\n * the remote server.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given\n * a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service\n * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is\n * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`\n * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See\n * https://developers.arcgis.com/rest/services-reference/export-map.htm\n * for further reference.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * The projection code must contain a numeric end portion separated by :\n * or the entire code must form a valid ArcGIS SpatialReference definition.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,\n * `2` means twice the size of the map viewport, and so on.\n * @property {Array<number>} [resolutions] Resolutions. If specified, requests will be made for\n * these resolutions only.\n * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url\n * should include /MapServer or /ImageServer.\n */\n\n/**\n * @classdesc\n * Source for data from ArcGIS Rest services providing single, untiled images.\n * Useful when underlying map service has labels.\n *\n * If underlying map service is not using labels,\n * take advantage of ol image caching and use\n * {@link module:ol/source/TileArcGISRest~TileArcGISRest} data source.\n *\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageArcGISRest extends ImageSource {\n  /**\n   * @param {Options} [options] Image ArcGIS Rest Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n    });\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").LoadFunction}\n     */\n    this.imageLoadFunction_ =\n      options.imageLoadFunction !== undefined\n        ? options.imageLoadFunction\n        : defaultImageLoadFunction;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.url_ === undefined) {\n      return null;\n    }\n\n    resolution = this.findNearestResolution(resolution);\n    pixelRatio = this.hidpi_ ? pixelRatio : 1;\n\n    const image = this.image_;\n    if (\n      image &&\n      this.renderedRevision_ == this.getRevision() &&\n      image.getResolution() == resolution &&\n      image.getPixelRatio() == pixelRatio &&\n      containsExtent(image.getExtent(), extent)\n    ) {\n      return image;\n    }\n\n    const params = {\n      'F': 'image',\n      'FORMAT': 'PNG32',\n      'TRANSPARENT': true,\n    };\n    Object.assign(params, this.params_);\n\n    extent = extent.slice();\n    const centerX = (extent[0] + extent[2]) / 2;\n    const centerY = (extent[1] + extent[3]) / 2;\n    if (this.ratio_ != 1) {\n      const halfWidth = (this.ratio_ * getWidth(extent)) / 2;\n      const halfHeight = (this.ratio_ * getHeight(extent)) / 2;\n      extent[0] = centerX - halfWidth;\n      extent[1] = centerY - halfHeight;\n      extent[2] = centerX + halfWidth;\n      extent[3] = centerY + halfHeight;\n    }\n\n    const imageResolution = resolution / pixelRatio;\n\n    // Compute an integer width and height.\n    const width = Math.ceil(getWidth(extent) / imageResolution);\n    const height = Math.ceil(getHeight(extent) / imageResolution);\n\n    // Modify the extent to match the integer width and height.\n    extent[0] = centerX - (imageResolution * width) / 2;\n    extent[2] = centerX + (imageResolution * width) / 2;\n    extent[1] = centerY - (imageResolution * height) / 2;\n    extent[3] = centerY + (imageResolution * height) / 2;\n\n    this.imageSize_[0] = width;\n    this.imageSize_[1] = height;\n\n    const url = this.getRequestUrl_(\n      extent,\n      this.imageSize_,\n      pixelRatio,\n      projection,\n      params\n    );\n\n    this.image_ = new ImageWrapper(\n      extent,\n      resolution,\n      pixelRatio,\n      url,\n      this.crossOrigin_,\n      this.imageLoadFunction_\n    );\n\n    this.renderedRevision_ = this.getRevision();\n\n    this.image_.addEventListener(\n      EventType.CHANGE,\n      this.handleImageChange.bind(this)\n    );\n\n    return this.image_;\n  }\n\n  /**\n   * Return the image load function of the source.\n   * @return {import(\"../Image.js\").LoadFunction} The image load function.\n   * @api\n   */\n  getImageLoadFunction() {\n    return this.imageLoadFunction_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../size.js\").Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string} Request URL.\n   * @private\n   */\n  getRequestUrl_(extent, size, pixelRatio, projection, params) {\n    // ArcGIS Server only wants the numeric portion of the projection ID.\n    // (if there is no numeric portion the entire projection code must\n    // form a valid ArcGIS SpatialReference definition).\n    const srid = projection\n      .getCode()\n      .split(/:(?=\\d+$)/)\n      .pop();\n\n    params['SIZE'] = size[0] + ',' + size[1];\n    params['BBOX'] = extent.join(',');\n    params['BBOXSR'] = srid;\n    params['IMAGESR'] = srid;\n    params['DPI'] = Math.round(90 * pixelRatio);\n\n    const url = this.url_;\n\n    const modifiedUrl = url\n      .replace(/MapServer\\/?$/, 'MapServer/export')\n      .replace(/ImageServer\\/?$/, 'ImageServer/exportImage');\n    if (modifiedUrl == url) {\n      assert(false, 50); // `options.featureTypes` should be an Array\n    }\n    return appendParams(modifiedUrl, params);\n  }\n\n  /**\n   * Return the URL used for this ArcGIS source.\n   * @return {string|undefined} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * Set the image load function of the source.\n   * @param {import(\"../Image.js\").LoadFunction} imageLoadFunction Image load function.\n   * @api\n   */\n  setImageLoadFunction(imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string|undefined} url URL.\n   * @api\n   */\n  setUrl(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.image_ = null;\n      this.changed();\n    }\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.image_ = null;\n    this.changed();\n  }\n}\n\nexport default ImageArcGISRest;\n", "/**\n * @module ol/source/ImageCanvas\n */\n\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageSource from './Image.js';\nimport {\n  containsExtent,\n  getHeight,\n  getWidth,\n  scaleFromCenter,\n} from '../extent.js';\n\n/**\n * A function returning the canvas element (`{HTMLCanvasElement}`)\n * used by the source as an image. The arguments passed to the function are:\n * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,\n * `{number}` the pixel ratio of the map, {@link module:ol/size~Size} the image size,\n * and {@link module:ol/proj/Projection~Projection} the image projection. The canvas returned by\n * this function is cached by the source. The this keyword inside the function\n * references the {@link module:ol/source/ImageCanvas~ImageCanvasSource}.\n *\n * @typedef {function(this:import(\"../ImageCanvas.js\").default, import(\"../extent.js\").Extent, number,\n *     number, import(\"../size.js\").Size, import(\"../proj/Projection.js\").default): HTMLCanvasElement} FunctionType\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {FunctionType} [canvasFunction] Canvas function.\n * The function returning the canvas element used by the source\n * as an image. The arguments passed to the function are: {@link import(\"../extent.js\").Extent} the\n * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,\n * {@link import(\"../size.js\").Size} the image size, and {@link import(\"../proj/Projection.js\").default} the image\n * projection. The canvas returned by this function is cached by the source. If\n * the value returned by the function is later changed then\n * `changed` should be called on the source for the source to\n * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the\n * width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, new canvases will be created for these resolutions\n * @property {import(\"./Source.js\").State} [state] Source state.\n */\n\n/**\n * @classdesc\n * Base class for image sources where a canvas element is the image.\n * @api\n */\nclass ImageCanvasSource extends ImageSource {\n  /**\n   * @param {Options} [options] ImageCanvas options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n      state: options.state,\n    });\n\n    /**\n     * @private\n     * @type {FunctionType}\n     */\n    this.canvasFunction_ = options.canvasFunction;\n\n    /**\n     * @private\n     * @type {import(\"../ImageCanvas.js\").default}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    resolution = this.findNearestResolution(resolution);\n\n    let canvas = this.canvas_;\n    if (\n      canvas &&\n      this.renderedRevision_ == this.getRevision() &&\n      canvas.getResolution() == resolution &&\n      canvas.getPixelRatio() == pixelRatio &&\n      containsExtent(canvas.getExtent(), extent)\n    ) {\n      return canvas;\n    }\n\n    extent = extent.slice();\n    scaleFromCenter(extent, this.ratio_);\n    const width = getWidth(extent) / resolution;\n    const height = getHeight(extent) / resolution;\n    const size = [width * pixelRatio, height * pixelRatio];\n\n    const canvasElement = this.canvasFunction_.call(\n      this,\n      extent,\n      resolution,\n      pixelRatio,\n      size,\n      projection\n    );\n    if (canvasElement) {\n      canvas = new ImageCanvas(extent, resolution, pixelRatio, canvasElement);\n    }\n    this.canvas_ = canvas;\n    this.renderedRevision_ = this.getRevision();\n\n    return canvas;\n  }\n}\n\nexport default ImageCanvasSource;\n", "/**\n * @module ol/source/ImageMapGuide\n */\n\nimport EventType from '../events/EventType.js';\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport ImageWrapper from '../Image.js';\nimport {appendParams} from '../uri.js';\nimport {\n  containsExtent,\n  getCenter,\n  getHeight,\n  getWidth,\n  scaleFromCenter,\n} from '../extent.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [url] The mapagent url.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {number} [displayDpi=96] The display resolution.\n * @property {number} [metersPerUnit=1] The meters-per-unit value.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, requests will be made for these resolutions only.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object} [params] Additional parameters.\n */\n\n/**\n * @classdesc\n * Source for images from Mapguide servers\n *\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageMapGuide extends ImageSource {\n  /**\n   * @param {Options} options ImageMapGuide options.\n   */\n  constructor(options) {\n    super({\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n    });\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.displayDpi_ =\n      options.displayDpi !== undefined ? options.displayDpi : 96;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").LoadFunction}\n     */\n    this.imageLoadFunction_ =\n      options.imageLoadFunction !== undefined\n        ? options.imageLoadFunction\n        : defaultImageLoadFunction;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.metersPerUnit_ =\n      options.metersPerUnit !== undefined ? options.metersPerUnit : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useOverlay_ =\n      options.useOverlay !== undefined ? options.useOverlay : false;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    resolution = this.findNearestResolution(resolution);\n    pixelRatio = this.hidpi_ ? pixelRatio : 1;\n\n    let image = this.image_;\n    if (\n      image &&\n      this.renderedRevision_ == this.getRevision() &&\n      image.getResolution() == resolution &&\n      image.getPixelRatio() == pixelRatio &&\n      containsExtent(image.getExtent(), extent)\n    ) {\n      return image;\n    }\n\n    if (this.ratio_ != 1) {\n      extent = extent.slice();\n      scaleFromCenter(extent, this.ratio_);\n    }\n    const width = getWidth(extent) / resolution;\n    const height = getHeight(extent) / resolution;\n    const size = [width * pixelRatio, height * pixelRatio];\n\n    if (this.url_ !== undefined) {\n      const imageUrl = this.getUrl(\n        this.url_,\n        this.params_,\n        extent,\n        size,\n        projection\n      );\n      image = new ImageWrapper(\n        extent,\n        resolution,\n        pixelRatio,\n        imageUrl,\n        this.crossOrigin_,\n        this.imageLoadFunction_\n      );\n      image.addEventListener(\n        EventType.CHANGE,\n        this.handleImageChange.bind(this)\n      );\n    } else {\n      image = null;\n    }\n    this.image_ = image;\n    this.renderedRevision_ = this.getRevision();\n\n    return image;\n  }\n\n  /**\n   * Return the image load function of the source.\n   * @return {import(\"../Image.js\").LoadFunction} The image load function.\n   * @api\n   */\n  getImageLoadFunction() {\n    return this.imageLoadFunction_;\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.changed();\n  }\n\n  /**\n   * @param {string} baseUrl The mapagent url.\n   * @param {Object<string, string|number>} params Request parameters.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../size.js\").Size} size Size.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string} The mapagent map image request URL.\n   */\n  getUrl(baseUrl, params, extent, size, projection) {\n    const scale = getScale(extent, size, this.metersPerUnit_, this.displayDpi_);\n    const center = getCenter(extent);\n    const baseParams = {\n      'OPERATION': this.useOverlay_\n        ? 'GETDYNAMICMAPOVERLAYIMAGE'\n        : 'GETMAPIMAGE',\n      'VERSION': '2.0.0',\n      'LOCALE': 'en',\n      'CLIENTAGENT': 'ol/source/ImageMapGuide source',\n      'CLIP': '1',\n      'SETDISPLAYDPI': this.displayDpi_,\n      'SETDISPLAYWIDTH': Math.round(size[0]),\n      'SETDISPLAYHEIGHT': Math.round(size[1]),\n      'SETVIEWSCALE': scale,\n      'SETVIEWCENTERX': center[0],\n      'SETVIEWCENTERY': center[1],\n    };\n    Object.assign(baseParams, params);\n    return appendParams(baseUrl, baseParams);\n  }\n\n  /**\n   * Set the image load function of the MapGuide source.\n   * @param {import(\"../Image.js\").LoadFunction} imageLoadFunction Image load function.\n   * @api\n   */\n  setImageLoadFunction(imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  }\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent The map extents.\n * @param {import(\"../size.js\").Size} size The viewport size.\n * @param {number} metersPerUnit The meters-per-unit value.\n * @param {number} dpi The display resolution.\n * @return {number} The computed map scale.\n */\nfunction getScale(extent, size, metersPerUnit, dpi) {\n  const mcsW = getWidth(extent);\n  const mcsH = getHeight(extent);\n  const devW = size[0];\n  const devH = size[1];\n  const mpp = 0.0254 / dpi;\n  if (devH * mcsW > devW * mcsH) {\n    return (mcsW * metersPerUnit) / (devW * mpp); // width limited\n  } else {\n    return (mcsH * metersPerUnit) / (devH * mpp); // height limited\n  }\n}\n\nexport default ImageMapGuide;\n", "/**\n * @module ol/source/ImageStatic\n */\n\nimport EventType from '../events/EventType.js';\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport ImageState from '../ImageState.js';\nimport ImageWrapper from '../Image.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {getHeight, getWidth, intersects} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {import(\"../extent.js\").Extent} [imageExtent] Extent of the image in map coordinates.\n * This is the [left, bottom, right, top] map coordinates of your image.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {import(\"../size.js\").Size} [imageSize] Size of the image in pixels. Usually the image size is auto-detected, so this\n * only needs to be set if auto-detection fails for some reason.\n * @property {string} url Image URL.\n */\n\n/**\n * @classdesc\n * A layer source for displaying a single, static image.\n * @api\n */\nclass Static extends ImageSource {\n  /**\n   * @param {Options} options ImageStatic options.\n   */\n  constructor(options) {\n    const crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    const /** @type {import(\"../Image.js\").LoadFunction} */ imageLoadFunction =\n        options.imageLoadFunction !== undefined\n          ? options.imageLoadFunction\n          : defaultImageLoadFunction;\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: getProjection(options.projection),\n    });\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.imageExtent_ = options.imageExtent;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image_ = new ImageWrapper(\n      this.imageExtent_,\n      undefined,\n      1,\n      this.url_,\n      crossOrigin,\n      imageLoadFunction\n    );\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size|null}\n     */\n    this.imageSize_ = options.imageSize ? options.imageSize : null;\n\n    this.image_.addEventListener(\n      EventType.CHANGE,\n      this.handleImageChange.bind(this)\n    );\n  }\n\n  /**\n   * Returns the image extent\n   * @return {import(\"../extent.js\").Extent} image extent.\n   * @api\n   */\n  getImageExtent() {\n    return this.imageExtent_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (intersects(extent, this.image_.getExtent())) {\n      return this.image_;\n    }\n    return null;\n  }\n\n  /**\n   * Return the URL used for this image source.\n   * @return {string} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   */\n  handleImageChange(evt) {\n    if (this.image_.getState() == ImageState.LOADED) {\n      const imageExtent = this.image_.getExtent();\n      const image = this.image_.getImage();\n      let imageWidth, imageHeight;\n      if (this.imageSize_) {\n        imageWidth = this.imageSize_[0];\n        imageHeight = this.imageSize_[1];\n      } else {\n        imageWidth = image.width;\n        imageHeight = image.height;\n      }\n      const extentWidth = getWidth(imageExtent);\n      const extentHeight = getHeight(imageExtent);\n      const xResolution = extentWidth / imageWidth;\n      const yResolution = extentHeight / imageHeight;\n      let targetWidth = imageWidth;\n      let targetHeight = imageHeight;\n      if (xResolution > yResolution) {\n        targetWidth = Math.round(extentWidth / yResolution);\n      } else {\n        targetHeight = Math.round(extentHeight / xResolution);\n      }\n      if (targetWidth !== imageWidth || targetHeight !== imageHeight) {\n        const context = createCanvasContext2D(targetWidth, targetHeight);\n        if (!this.getInterpolate()) {\n          context.imageSmoothingEnabled = false;\n        }\n        const canvas = context.canvas;\n        context.drawImage(\n          image,\n          0,\n          0,\n          imageWidth,\n          imageHeight,\n          0,\n          0,\n          canvas.width,\n          canvas.height\n        );\n        this.image_.setImage(canvas);\n      }\n    }\n    super.handleImageChange(evt);\n  }\n}\n\nexport default Static;\n", "/**\n * @module ol/source/ImageWMS\n */\n\nimport EventType from '../events/EventType.js';\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport ImageWrapper from '../Image.js';\nimport {DEFAULT_VERSION} from './wms.js';\nimport {appendParams} from '../uri.js';\nimport {assert} from '../asserts.js';\nimport {calculateSourceResolution} from '../reproj.js';\nimport {ceil, floor, round} from '../math.js';\nimport {compareVersions} from '../string.js';\nimport {\n  containsExtent,\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n} from '../extent.js';\nimport {get as getProjection, transform} from '../proj.js';\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 4;\n\n/**\n * @const\n * @type {import(\"../size.js\").Size}\n */\nconst GETFEATUREINFO_IMAGE_SIZE = [101, 101];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\n * Only needed if `hidpi` is `true`.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} [params] WMS request parameters.\n * At least a `LAYERS` param is required. `STYLES` is\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`\n * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or\n * higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, requests will be made for these resolutions only.\n * @property {string} [url] WMS service URL.\n */\n\n/**\n * @classdesc\n * Source for WMS servers providing single, untiled images.\n *\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageWMS extends ImageSource {\n  /**\n   * @param {Options} [options] ImageWMS options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n    });\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").LoadFunction}\n     */\n    this.imageLoadFunction_ =\n      options.imageLoadFunction !== undefined\n        ? options.imageLoadFunction\n        : defaultImageLoadFunction;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = Object.assign({}, options.params);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.v13_ = true;\n    this.updateV13_();\n\n    /**\n     * @private\n     * @type {import(\"./wms.js\").ServerType}\n     */\n    this.serverType_ = options.serverType;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n  }\n\n  /**\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\n   * constructed.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\n   *     specified here.\n   * @return {string|undefined} GetFeatureInfo URL.\n   * @api\n   */\n  getFeatureInfoUrl(coordinate, resolution, projection, params) {\n    if (this.url_ === undefined) {\n      return undefined;\n    }\n    const projectionObj = getProjection(projection);\n    const sourceProjectionObj = this.getProjection();\n\n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      resolution = calculateSourceResolution(\n        sourceProjectionObj,\n        projectionObj,\n        coordinate,\n        resolution\n      );\n      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);\n    }\n\n    const extent = getForViewAndSize(\n      coordinate,\n      resolution,\n      0,\n      GETFEATUREINFO_IMAGE_SIZE\n    );\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'REQUEST': 'GetFeatureInfo',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n      'QUERY_LAYERS': this.params_['LAYERS'],\n    };\n    Object.assign(baseParams, this.params_, params);\n\n    const x = floor((coordinate[0] - extent[0]) / resolution, DECIMALS);\n    const y = floor((extent[3] - coordinate[1]) / resolution, DECIMALS);\n    baseParams[this.v13_ ? 'I' : 'X'] = x;\n    baseParams[this.v13_ ? 'J' : 'Y'] = y;\n\n    return this.getRequestUrl_(\n      extent,\n      GETFEATUREINFO_IMAGE_SIZE,\n      1,\n      sourceProjectionObj || projectionObj,\n      baseParams\n    );\n  }\n\n  /**\n   * Return the GetLegendGraphic URL, optionally optimized for the passed\n   * resolution and possibly including any passed specific parameters. Returns\n   * `undefined` if the GetLegendGraphic URL cannot be constructed.\n   *\n   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`\n   *     will not be calculated and included in URL.\n   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the\n   *     request is generated for this wms layer, else it will try to use the\n   *     configured wms layer. Default `FORMAT` is `image/png`.\n   *     `VERSION` should not be specified here.\n   * @return {string|undefined} GetLegendGraphic URL.\n   * @api\n   */\n  getLegendUrl(resolution, params) {\n    if (this.url_ === undefined) {\n      return undefined;\n    }\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'REQUEST': 'GetLegendGraphic',\n      'FORMAT': 'image/png',\n    };\n\n    if (params === undefined || params['LAYER'] === undefined) {\n      const layers = this.params_.LAYERS;\n      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n      if (!isSingleLayer) {\n        return undefined;\n      }\n      baseParams['LAYER'] = layers;\n    }\n\n    if (resolution !== undefined) {\n      const mpu = this.getProjection()\n        ? this.getProjection().getMetersPerUnit()\n        : 1;\n      const pixelSize = 0.00028;\n      baseParams['SCALE'] = (resolution * mpu) / pixelSize;\n    }\n\n    Object.assign(baseParams, params);\n\n    return appendParams(/** @type {string} */ (this.url_), baseParams);\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.url_ === undefined) {\n      return null;\n    }\n\n    resolution = this.findNearestResolution(resolution);\n\n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {\n      pixelRatio = 1;\n    }\n\n    const imageResolution = resolution / pixelRatio;\n\n    const center = getCenter(extent);\n    const viewWidth = ceil(getWidth(extent) / imageResolution, DECIMALS);\n    const viewHeight = ceil(getHeight(extent) / imageResolution, DECIMALS);\n    const viewExtent = getForViewAndSize(center, imageResolution, 0, [\n      viewWidth,\n      viewHeight,\n    ]);\n    const requestWidth = ceil(\n      (this.ratio_ * getWidth(extent)) / imageResolution,\n      DECIMALS\n    );\n    const requestHeight = ceil(\n      (this.ratio_ * getHeight(extent)) / imageResolution,\n      DECIMALS\n    );\n    const requestExtent = getForViewAndSize(center, imageResolution, 0, [\n      requestWidth,\n      requestHeight,\n    ]);\n\n    const image = this.image_;\n    if (\n      image &&\n      this.renderedRevision_ == this.getRevision() &&\n      image.getResolution() == resolution &&\n      image.getPixelRatio() == pixelRatio &&\n      containsExtent(image.getExtent(), viewExtent)\n    ) {\n      return image;\n    }\n\n    const params = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'REQUEST': 'GetMap',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n    };\n    Object.assign(params, this.params_);\n\n    this.imageSize_[0] = round(\n      getWidth(requestExtent) / imageResolution,\n      DECIMALS\n    );\n    this.imageSize_[1] = round(\n      getHeight(requestExtent) / imageResolution,\n      DECIMALS\n    );\n\n    const url = this.getRequestUrl_(\n      requestExtent,\n      this.imageSize_,\n      pixelRatio,\n      projection,\n      params\n    );\n\n    this.image_ = new ImageWrapper(\n      requestExtent,\n      resolution,\n      pixelRatio,\n      url,\n      this.crossOrigin_,\n      this.imageLoadFunction_\n    );\n\n    this.renderedRevision_ = this.getRevision();\n\n    this.image_.addEventListener(\n      EventType.CHANGE,\n      this.handleImageChange.bind(this)\n    );\n\n    return this.image_;\n  }\n\n  /**\n   * Return the image load function of the source.\n   * @return {import(\"../Image.js\").LoadFunction} The image load function.\n   * @api\n   */\n  getImageLoadFunction() {\n    return this.imageLoadFunction_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../size.js\").Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string} Request URL.\n   * @private\n   */\n  getRequestUrl_(extent, size, pixelRatio, projection, params) {\n    assert(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`\n\n    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();\n\n    if (!('STYLES' in this.params_)) {\n      params['STYLES'] = '';\n    }\n\n    if (pixelRatio != 1) {\n      switch (this.serverType_) {\n        case 'geoserver':\n          const dpi = (90 * pixelRatio + 0.5) | 0;\n          if ('FORMAT_OPTIONS' in params) {\n            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\n          } else {\n            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\n          }\n          break;\n        case 'mapserver':\n          params['MAP_RESOLUTION'] = 90 * pixelRatio;\n          break;\n        case 'carmentaserver':\n        case 'qgis':\n          params['DPI'] = 90 * pixelRatio;\n          break;\n        default: // Unknown `serverType` configured\n          assert(false, 8);\n          break;\n      }\n    }\n\n    params['WIDTH'] = size[0];\n    params['HEIGHT'] = size[1];\n\n    const axisOrientation = projection.getAxisOrientation();\n    let bbox;\n    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {\n      bbox = [extent[1], extent[0], extent[3], extent[2]];\n    } else {\n      bbox = extent;\n    }\n    params['BBOX'] = bbox.join(',');\n\n    return appendParams(/** @type {string} */ (this.url_), params);\n  }\n\n  /**\n   * Return the URL used for this WMS source.\n   * @return {string|undefined} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * Set the image load function of the source.\n   * @param {import(\"../Image.js\").LoadFunction} imageLoadFunction Image load function.\n   * @api\n   */\n  setImageLoadFunction(imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string|undefined} url URL.\n   * @api\n   */\n  setUrl(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.image_ = null;\n      this.changed();\n    }\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.updateV13_();\n    this.image_ = null;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  updateV13_() {\n    const version = this.params_['VERSION'] || DEFAULT_VERSION;\n    this.v13_ = compareVersions(version, '1.3') >= 0;\n  }\n}\n\nexport default ImageWMS;\n", "/**\n * @module ol/source/wms\n */\n\n/**\n * Default WMS version.\n * @type {string}\n */\nexport const DEFAULT_VERSION = '1.3.0';\n\n/**\n * @api\n * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType\n * Set the server type to use implementation-specific parameters beyond the WMS specification.\n *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)\n *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)\n *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)\n *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)\n */\n", "/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {create as createTransform} from '../transform.js';\nimport {equals, getCenter, getHeight, getWidth} from '../extent.js';\nimport {getUid} from '../util.js';\n\nlet hasImageData = true;\ntry {\n  new ImageData(10, 10);\n} catch (_) {\n  hasImageData = false;\n}\n\n/** @type {CanvasRenderingContext2D} */\nlet context;\n\n/**\n * @param {Uint8ClampedArray} data Image data.\n * @param {number} width Number of columns.\n * @param {number} height Number of rows.\n * @return {ImageData} Image data.\n */\nexport function newImageData(data, width, height) {\n  if (hasImageData) {\n    return new ImageData(data, width, height);\n  }\n\n  if (!context) {\n    context = document.createElement('canvas').getContext('2d');\n  }\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  return imageData;\n}\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  let workerHasImageData = true;\n  try {\n    new ImageData(10, 10);\n  } catch (_) {\n    workerHasImageData = false;\n  }\n\n  function newWorkerImageData(data, width, height) {\n    if (workerHasImageData) {\n      return new ImageData(data, width, height);\n    } else {\n      return {data: data, width: width, height: height};\n    }\n  }\n\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = newWorkerImageData(\n          new Uint8ClampedArray(buffers[b]),\n          width,\n          height\n        );\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n\n  const lines = lib.concat([\n    'const __minion__ = (' + createMinion.toString() + ')(',\n    config.operation.toString(),\n    ');',\n    'self.addEventListener(\"message\", function(event) {',\n    '  const buffer = __minion__(event.data);',\n    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n    '});',\n  ]);\n\n  const worker = new Worker(\n    typeof Blob === 'undefined'\n      ? 'data:text/javascript;base64,' +\n        Buffer.from(lines.join('\\n'), 'binary').toString('base64')\n      : URL.createObjectURL(new Blob(lines, {type: 'text/javascript'}))\n  );\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({data: {buffer: minion(data), meta: data['meta']}});\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    },\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    this._imageOps = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this._imageOps) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(\n        config,\n        this._onWorkerMessage.bind(this, 0)\n      );\n    }\n    this._workers = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this._queue = [];\n\n    this._maxQueueLength = config.queue || Infinity;\n    this._running = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this._dataLookup = {};\n\n    /**\n     * @type {Job}\n     * @private\n     */\n    this._job = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this._enqueue({\n      inputs: inputs,\n      meta: meta,\n      callback: callback,\n    });\n    this._dispatch();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  _enqueue(job) {\n    this._queue.push(job);\n    while (this._queue.length > this._maxQueueLength) {\n      this._queue.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  _dispatch() {\n    if (this._running || this._queue.length === 0) {\n      return;\n    }\n\n    const job = this._queue.shift();\n    this._job = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this._workers.length;\n    this._running = threads;\n    if (threads === 1) {\n      this._workers[0].postMessage(\n        {\n          buffers: buffers,\n          meta: job.meta,\n          imageOps: this._imageOps,\n          width: width,\n          height: height,\n        },\n        buffers\n      );\n      return;\n    }\n\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this._workers[i].postMessage(\n        {\n          buffers: slices,\n          meta: job.meta,\n          imageOps: this._imageOps,\n          width: width,\n          height: height,\n        },\n        slices\n      );\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  _onWorkerMessage(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this._dataLookup[index] = event.data;\n    --this._running;\n    if (this._running === 0) {\n      this._resolveJob();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  _resolveJob() {\n    const job = this._job;\n    const threads = this._workers.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);\n      meta = this._dataLookup[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this._dataLookup[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this._dataLookup[i]['meta'];\n      }\n    }\n    this._job = null;\n    this._dataLookup = {};\n    job.callback(\n      null,\n      newImageData(data, job.inputs[0].width, job.inputs[0].height),\n      meta\n    );\n    this._dispatch();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   */\n  disposeInternal() {\n    for (let i = 0; i < this._workers.length; ++i) {\n      this._workers[i].terminate();\n    }\n    this._workers.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations',\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null,\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ =\n      options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.changed.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutterTree: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */ ({\n        rotation: 0,\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {},\n    };\n\n    this.setAttributions(function (frameState) {\n      const attributions = [];\n      for (\n        let index = 0, iMax = options.sources.length;\n        index < iMax;\n        ++index\n      ) {\n        const sourceOrLayer = options.sources[index];\n        const source =\n          sourceOrLayer instanceof Source\n            ? sourceOrLayer\n            : sourceOrLayer.getSource();\n        const attributionGetter = source.getAttributions();\n        if (typeof attributionGetter === 'function') {\n          const sourceAttribution = attributionGetter(frameState);\n          attributions.push.apply(attributions, sourceAttribution);\n        }\n      }\n      return attributions.length !== 0 ? attributions : null;\n    });\n\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */ (\n      Object.assign({}, this.frameState_)\n    );\n\n    frameState.viewState = /** @type {import(\"../View.js\").State} */ (\n      Object.assign({}, frameState.viewState)\n    );\n\n    const center = getCenter(extent);\n\n    frameState.extent = extent.slice();\n    frameState.size[0] = Math.round(getWidth(extent) / resolution);\n    frameState.size[1] = Math.round(getHeight(extent) / resolution);\n    frameState.time = Date.now();\n\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (\n        resolution !== renderedResolution ||\n        !equals(extent, renderedExtent)\n      ) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n\n    if (\n      !this.renderedImageCanvas_ ||\n      this.getRevision() !== this.renderedRevision_\n    ) {\n      this.processSources_();\n    }\n\n    frameState.tileQueue.loadMoreTiles(16, 16);\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n\n    const data = {};\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data)\n    );\n    this.processor_.process(\n      imageDatas,\n      data,\n      this.onWorkerComplete_.bind(this, frameState)\n    );\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (\n      resolution !== this.requestedFrameState_.viewState.resolution ||\n      !equals(extent, this.requestedFrameState_.extent)\n    ) {\n      return;\n    }\n\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(\n        extent,\n        resolution,\n        1,\n        context.canvas\n      );\n    }\n    context.putImageData(output, 0, 0);\n\n    this.changed();\n    this.renderedRevision_ = this.getRevision();\n\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data)\n    );\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n  }\n\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height);\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height);\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({source: layerOrSource});\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({source: layerOrSource});\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\n\nexport default RasterSource;\n", "/**\n * @module ol/source/TileArcGISRest\n */\n\nimport TileImage from './TileImage.js';\nimport {appendParams} from '../uri.js';\nimport {createEmpty} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {hash as tileCoordHash} from '../tilecoord.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be\n * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by\n * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,\n * and `IMAGESR` will be set dynamically. Set `LAYERS` to\n * override the default service layer visibility. See\n * https://developers.arcgis.com/rest/services-reference/export-map.htm\n * for further reference.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid. Base this on the resolutions,\n * tilesize and extent supported by the server.\n * If this is not defined, a default grid will be used: if there is a projection\n * extent, the grid will be based on that; if not, a grid based on a global\n * extent with origin at 0,0 will be used.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * The projection code must contain a numeric end portion separated by :\n * or the entire code must form a valid ArcGIS SpatialReference definition.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.\n * The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The\n * url should include /MapServer or /ImageServer.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity\n * transition, pass `transition: 0`.\n * @property {Array<string>} [urls] ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS\n * Service supports multiple urls for export requests.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from ArcGIS Rest services. Map and Image\n * Services are supported.\n *\n * For cached ArcGIS services, better performance is available using the\n * {@link module:ol/source/XYZ~XYZ} data source.\n * @api\n */\nclass TileArcGISRest extends TileImage {\n  /**\n   * @param {Options} [options] Tile ArcGIS Rest options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = createEmpty();\n\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @private\n   * @return {string} The key for the current params.\n   */\n  getKeyForParams_() {\n    let i = 0;\n    const res = [];\n    for (const key in this.params_) {\n      res[i++] = key + '-' + this.params_[key];\n    }\n    return res.join('/');\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../size.js\").Size} tileSize Tile size.\n   * @param {import(\"../extent.js\").Extent} tileExtent Tile extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string|undefined} Request URL.\n   * @private\n   */\n  getRequestUrl_(\n    tileCoord,\n    tileSize,\n    tileExtent,\n    pixelRatio,\n    projection,\n    params\n  ) {\n    const urls = this.urls;\n    if (!urls) {\n      return undefined;\n    }\n\n    // ArcGIS Server only wants the numeric portion of the projection ID.\n    // (if there is no numeric portion the entire projection code must\n    // form a valid ArcGIS SpatialReference definition).\n    const srid = projection\n      .getCode()\n      .split(/:(?=\\d+$)/)\n      .pop();\n\n    params['SIZE'] = tileSize[0] + ',' + tileSize[1];\n    params['BBOX'] = tileExtent.join(',');\n    params['BBOXSR'] = srid;\n    params['IMAGESR'] = srid;\n    params['DPI'] = Math.round(\n      params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio\n    );\n\n    let url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      const index = modulo(tileCoordHash(tileCoord), urls.length);\n      url = urls[index];\n    }\n\n    const modifiedUrl = url\n      .replace(/MapServer\\/?$/, 'MapServer/export')\n      .replace(/ImageServer\\/?$/, 'ImageServer/exportImage');\n    return appendParams(modifiedUrl, params);\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.hidpi_ ? pixelRatio : 1;\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord The tile coordinate\n   * @param {number} pixelRatio The pixel ratio\n   * @param {import(\"../proj/Projection.js\").default} projection The projection\n   * @return {string|undefined} The tile URL\n   * @override\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    let tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n\n    if (pixelRatio != 1 && !this.hidpi_) {\n      pixelRatio = 1;\n    }\n\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n\n    if (pixelRatio != 1) {\n      tileSize = scaleSize(tileSize, pixelRatio, this.tmpSize);\n    }\n\n    // Apply default params and override with user specified values.\n    const baseParams = {\n      'F': 'image',\n      'FORMAT': 'PNG32',\n      'TRANSPARENT': true,\n    };\n    Object.assign(baseParams, this.params_);\n\n    return this.getRequestUrl_(\n      tileCoord,\n      tileSize,\n      tileExtent,\n      pixelRatio,\n      projection,\n      baseParams\n    );\n  }\n}\n\nexport default TileArcGISRest;\n", "/**\n * @module ol/source/TileDebug\n */\n\nimport XYZ from './XYZ.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Optional projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Set to `1` when debugging `VectorTile` sources with a default configuration.\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n * @property {string} [template='z:{z} x:{x} y:{y}'] Template for labeling the tiles.\n * Should include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n */\n\n/**\n * @classdesc\n * A pseudo tile source, which does not fetch tiles from a server, but renders\n * a grid outline for the tile grid/projection along with the coordinates for\n * each tile. See examples/canvas-tiles for an example.\n * @api\n */\nclass TileDebug extends XYZ {\n  /**\n   * @param {Options} [options] Debug tile options.\n   */\n  constructor(options) {\n    /**\n     * @type {Options}\n     */\n    options = options || {};\n\n    super({\n      opaque: false,\n      projection: options.projection,\n      tileGrid: options.tileGrid,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      zDirection: options.zDirection,\n      url: options.template || 'z:{z} x:{x} y:{y}',\n      tileLoadFunction: (tile, text) => {\n        const z = tile.getTileCoord()[0];\n        const tileSize = toSize(this.tileGrid.getTileSize(z));\n        const context = createCanvasContext2D(tileSize[0], tileSize[1]);\n\n        context.strokeStyle = 'grey';\n        context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);\n\n        context.fillStyle = 'grey';\n        context.strokeStyle = 'white';\n        context.textAlign = 'center';\n        context.textBaseline = 'middle';\n        context.font = '24px sans-serif';\n        context.lineWidth = 4;\n        context.strokeText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);\n        context.fillText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);\n\n        /** @type {import(\"../ImageTile.js\").default} */ (tile).setImage(\n          context.canvas\n        );\n      },\n    });\n  }\n}\n\nexport default TileDebug;\n", "/**\n * @module ol/source/TileWMS\n */\n\nimport TileImage from './TileImage.js';\nimport {DEFAULT_VERSION} from './wms.js';\nimport {appendParams} from '../uri.js';\nimport {assert} from '../asserts.js';\nimport {buffer, createEmpty} from '../extent.js';\nimport {buffer as bufferSize, scale as scaleSize, toSize} from '../size.js';\nimport {calculateSourceResolution} from '../reproj.js';\nimport {compareVersions} from '../string.js';\nimport {get as getProjection, transform, transformExtent} from '../proj.js';\nimport {modulo} from '../math.js';\nimport {hash as tileCoordHash} from '../tilecoord.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} params WMS request parameters.\n * At least a `LAYERS` param is required. `STYLES` is\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`\n * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.\n * @property {number} [gutter=0]\n * The size in pixels of the gutter around image tiles to ignore. By setting\n * this property to a non-zero value, images will be requested that are wider\n * and taller than the tile size by a value of `2 x gutter`.\n * Using a non-zero value allows artifacts of rendering at tile edges to be\n * ignored. If you control the WMS service it is recommended to address\n * \"artifacts at tile edges\" issues by properly configuring the WMS service. For\n * example, MapServer has a `tile_map_edge_buffer` configuration parameter for\n * this. See https://mapserver.org/output/tile_mode.html.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid. Base this on the resolutions,\n * tilesize and extent supported by the server.\n * If this is not defined, a default grid will be used: if there is a projection\n * extent, the grid will be based on that; if not, a grid based on a global\n * extent with origin at 0,0 will be used.\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\n * Only needed if `hidpi` is `true`.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url] WMS service URL.\n * @property {Array<string>} [urls] WMS service urls.\n * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When `true`, tiles will be requested for one world only,\n * but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from WMS servers.\n * @api\n */\nclass TileWMS extends TileImage {\n  /**\n   * @param {Options} [options] Tile WMS options.\n   */\n  constructor(options) {\n    options = options ? options : /** @type {Options} */ ({});\n\n    const params = Object.assign({}, options.params);\n\n    const transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      opaque: !transparent,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = params;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.v13_ = true;\n\n    /**\n     * @private\n     * @type {import(\"./wms.js\").ServerType}\n     */\n    this.serverType_ = options.serverType;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = createEmpty();\n\n    this.updateV13_();\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\n   * constructed.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\n   *     specified here.\n   * @return {string|undefined} GetFeatureInfo URL.\n   * @api\n   */\n  getFeatureInfoUrl(coordinate, resolution, projection, params) {\n    const projectionObj = getProjection(projection);\n    const sourceProjectionObj = this.getProjection();\n\n    let tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projectionObj);\n    }\n\n    const z = tileGrid.getZForResolution(resolution, this.zDirection);\n    const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n\n    let tileResolution = tileGrid.getResolution(tileCoord[0]);\n    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n\n    const gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileSize = bufferSize(tileSize, gutter, this.tmpSize);\n      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);\n    }\n\n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      tileResolution = calculateSourceResolution(\n        sourceProjectionObj,\n        projectionObj,\n        coordinate,\n        tileResolution\n      );\n      tileExtent = transformExtent(\n        tileExtent,\n        projectionObj,\n        sourceProjectionObj\n      );\n      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);\n    }\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'REQUEST': 'GetFeatureInfo',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n      'QUERY_LAYERS': this.params_['LAYERS'],\n    };\n    Object.assign(baseParams, this.params_, params);\n\n    const x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);\n    const y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);\n\n    baseParams[this.v13_ ? 'I' : 'X'] = x;\n    baseParams[this.v13_ ? 'J' : 'Y'] = y;\n\n    return this.getRequestUrl_(\n      tileCoord,\n      tileSize,\n      tileExtent,\n      1,\n      sourceProjectionObj || projectionObj,\n      baseParams\n    );\n  }\n\n  /**\n   * Return the GetLegendGraphic URL, optionally optimized for the passed\n   * resolution and possibly including any passed specific parameters. Returns\n   * `undefined` if the GetLegendGraphic URL cannot be constructed.\n   *\n   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`\n   *     will not be calculated and included in URL.\n   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the\n   *     request is generated for this wms layer, else it will try to use the\n   *     configured wms layer. Default `FORMAT` is `image/png`.\n   *     `VERSION` should not be specified here.\n   * @return {string|undefined} GetLegendGraphic URL.\n   * @api\n   */\n  getLegendUrl(resolution, params) {\n    if (this.urls[0] === undefined) {\n      return undefined;\n    }\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'REQUEST': 'GetLegendGraphic',\n      'FORMAT': 'image/png',\n    };\n\n    if (params === undefined || params['LAYER'] === undefined) {\n      const layers = this.params_.LAYERS;\n      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n      if (!isSingleLayer) {\n        return undefined;\n      }\n      baseParams['LAYER'] = layers;\n    }\n\n    if (resolution !== undefined) {\n      const mpu = this.getProjection()\n        ? this.getProjection().getMetersPerUnit()\n        : 1;\n      const pixelSize = 0.00028;\n      baseParams['SCALE'] = (resolution * mpu) / pixelSize;\n    }\n\n    Object.assign(baseParams, params);\n\n    return appendParams(/** @type {string} */ (this.urls[0]), baseParams);\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return this.gutter_;\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../size.js\").Size} tileSize Tile size.\n   * @param {import(\"../extent.js\").Extent} tileExtent Tile extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string|undefined} Request URL.\n   * @private\n   */\n  getRequestUrl_(\n    tileCoord,\n    tileSize,\n    tileExtent,\n    pixelRatio,\n    projection,\n    params\n  ) {\n    const urls = this.urls;\n    if (!urls) {\n      return undefined;\n    }\n\n    params['WIDTH'] = tileSize[0];\n    params['HEIGHT'] = tileSize[1];\n\n    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();\n\n    if (!('STYLES' in this.params_)) {\n      params['STYLES'] = '';\n    }\n\n    if (pixelRatio != 1) {\n      switch (this.serverType_) {\n        case 'geoserver':\n          const dpi = (90 * pixelRatio + 0.5) | 0;\n          if ('FORMAT_OPTIONS' in params) {\n            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\n          } else {\n            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\n          }\n          break;\n        case 'mapserver':\n          params['MAP_RESOLUTION'] = 90 * pixelRatio;\n          break;\n        case 'carmentaserver':\n        case 'qgis':\n          params['DPI'] = 90 * pixelRatio;\n          break;\n        default: // Unknown `serverType` configured\n          assert(false, 52);\n          break;\n      }\n    }\n\n    const axisOrientation = projection.getAxisOrientation();\n    const bbox = tileExtent;\n    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {\n      let tmp;\n      tmp = tileExtent[0];\n      bbox[0] = tileExtent[1];\n      bbox[1] = tmp;\n      tmp = tileExtent[2];\n      bbox[2] = tileExtent[3];\n      bbox[3] = tmp;\n    }\n    params['BBOX'] = bbox.join(',');\n\n    let url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      const index = modulo(tileCoordHash(tileCoord), urls.length);\n      url = urls[index];\n    }\n    return appendParams(url, params);\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;\n  }\n\n  /**\n   * @private\n   * @return {string} The key for the current params.\n   */\n  getKeyForParams_() {\n    let i = 0;\n    const res = [];\n    for (const key in this.params_) {\n      res[i++] = key + '-' + this.params_[key];\n    }\n    return res.join('/');\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.updateV13_();\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @private\n   */\n  updateV13_() {\n    const version = this.params_['VERSION'] || DEFAULT_VERSION;\n    this.v13_ = compareVersions(version, '1.3') >= 0;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord The tile coordinate\n   * @param {number} pixelRatio The pixel ratio\n   * @param {import(\"../proj/Projection.js\").default} projection The projection\n   * @return {string|undefined} The tile URL\n   * @override\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    let tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n\n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {\n      pixelRatio = 1;\n    }\n\n    const tileResolution = tileGrid.getResolution(tileCoord[0]);\n    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n\n    const gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileSize = bufferSize(tileSize, gutter, this.tmpSize);\n      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);\n    }\n\n    if (pixelRatio != 1) {\n      tileSize = scaleSize(tileSize, pixelRatio, this.tmpSize);\n    }\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'REQUEST': 'GetMap',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n    };\n    Object.assign(baseParams, this.params_);\n\n    return this.getRequestUrl_(\n      tileCoord,\n      tileSize,\n      tileExtent,\n      pixelRatio,\n      projection,\n      baseParams\n    );\n  }\n}\n\nexport default TileWMS;\n", "/**\n * @module ol/source/UTFGrid\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileSource from './Tile.js';\nimport TileState from '../TileState.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {assert} from '../asserts.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport {listenOnce} from '../events.js';\nimport {jsonp as requestJSONP} from '../net.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nexport class CustomTile extends Tile {\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative =\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    const yRelative =\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n  forDataAtCoordinate(coordinate, callback, request) {\n    if (this.state == TileState.EMPTY && request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(\n        this,\n        EventType.CHANGE,\n        function (e) {\n          callback(this.getData(coordinate));\n        },\n        this\n      );\n      this.loadInternal_();\n    } else {\n      if (request === true) {\n        setTimeout(\n          function () {\n            callback(this.getData(coordinate));\n          }.bind(this),\n          0\n        );\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.src_;\n  }\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(\n          this.src_,\n          this.handleLoad_.bind(this),\n          this.handleError_.bind(this)\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n  /**\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: 'loading',\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ =\n      options.preemptive !== undefined ? options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this)\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(coordinate, resolution, callback, request) {\n    if (this.tileGrid) {\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = /** @type {!CustomTile} */ (\n        this.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n          1,\n          this.getProjection()\n        )\n      );\n      tile.forDataAtCoordinate(coordinate, callback, request);\n    } else {\n      if (request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState('error');\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution'] !== undefined) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState('ready');\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    } else {\n      const tileCoord = [z, x, y];\n      const urlTileCoord = this.getTileCoordForTileUrlFunction(\n        tileCoord,\n        projection\n      );\n      const tileUrl = this.tileUrlFunction_(\n        urlTileCoord,\n        pixelRatio,\n        projection\n      );\n      const tile = new CustomTile(\n        tileCoord,\n        tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n        tileUrl !== undefined ? tileUrl : '',\n        this.tileGrid.getTileCoordExtent(tileCoord),\n        this.preemptive_,\n        this.jsonp_\n      );\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n  useTile(z, x, y) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  }\n}\n\nexport default UTFGrid;\n", "/**\n * @module ol/source\n */\n\nimport LRUCache from './structs/LRUCache.js';\nimport {getIntersection} from './extent.js';\n\nexport {default as BingMaps} from './source/BingMaps.js';\nexport {default as CartoDB} from './source/CartoDB.js';\nexport {default as Cluster} from './source/Cluster.js';\nexport {default as DataTile} from './source/DataTile.js';\nexport {default as GeoTIFF} from './source/GeoTIFF.js';\nexport {default as IIIF} from './source/IIIF.js';\nexport {default as Image} from './source/Image.js';\nexport {default as ImageArcGISRest} from './source/ImageArcGISRest.js';\nexport {default as ImageCanvas} from './source/ImageCanvas.js';\nexport {default as ImageMapGuide} from './source/ImageMapGuide.js';\nexport {default as ImageStatic} from './source/ImageStatic.js';\nexport {default as ImageWMS} from './source/ImageWMS.js';\nexport {default as OSM} from './source/OSM.js';\nexport {default as Raster} from './source/Raster.js';\nexport {default as Source} from './source/Source.js';\nexport {default as Stamen} from './source/Stamen.js';\nexport {default as Tile} from './source/Tile.js';\nexport {default as TileArcGISRest} from './source/TileArcGISRest.js';\nexport {default as TileDebug} from './source/TileDebug.js';\nexport {default as TileImage} from './source/TileImage.js';\nexport {default as TileJSON} from './source/TileJSON.js';\nexport {default as TileWMS} from './source/TileWMS.js';\nexport {default as UrlTile} from './source/UrlTile.js';\nexport {default as UTFGrid} from './source/UTFGrid.js';\nexport {default as Vector} from './source/Vector.js';\nexport {default as VectorTile} from './source/VectorTile.js';\nexport {default as WMTS} from './source/WMTS.js';\nexport {default as XYZ} from './source/XYZ.js';\nexport {default as Zoomify} from './source/Zoomify.js';\n\n/**\n * Creates a sources function from a tile grid. This function can be used as value for the\n * `sources` property of the {@link module:ol/layer/Layer~Layer} subclasses that support it.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @param {function(import(\"./tilecoord.js\").TileCoord): import(\"./source/Source.js\").default} factory Source factory.\n * This function takes a {@link module:ol/tilecoord~TileCoord} as argument and is expected to return a\n * {@link module:ol/source/Source~Source}. **Note**: The returned sources should have a tile grid with\n * a limited set of resolutions, matching the resolution range of a single zoom level of the pyramid\n * `tileGrid` that `sourcesFromTileGrid` was called with.\n * @return {function(import(\"./extent.js\").Extent, number): Array<import(\"./source/Source.js\").default>} Sources function.\n * @api\n */\nexport function sourcesFromTileGrid(tileGrid, factory) {\n  const sourceCache = new LRUCache(32);\n  const tileGridExtent = tileGrid.getExtent();\n  return function (extent, resolution) {\n    sourceCache.expireCache();\n    if (tileGridExtent) {\n      extent = getIntersection(tileGridExtent, extent);\n    }\n    const z = tileGrid.getZForResolution(resolution);\n    const wantedSources = [];\n    tileGrid.forEachTileCoord(extent, z, (tileCoord) => {\n      const key = tileCoord.toString();\n      if (!sourceCache.containsKey(key)) {\n        const source = factory(tileCoord);\n        sourceCache.set(key, source);\n      }\n      wantedSources.push(sourceCache.get(key));\n    });\n    return wantedSources;\n  };\n}\n"],
  "mappings": "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",
  "names": ["geometry", "context", "scale", "size", "sourceState", "Image_default", "Image_default", "extent", "resolution", "pixelRatio", "Image_default", "Image_default", "ImageCanvas_default", "Image_default", "scale", "Image_default", "context", "Image_default", "output", "buffer", "Image_default", "context", "Tile_default", "scale", "context", "buffer", "scale", "CustomTile", "jsonp", "Tile_default", "transform"]
}
