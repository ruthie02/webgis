import {
  equals,
  init_array
} from "./chunk-K4BY6QEO.js";
import {
  clear,
  init_obj
} from "./chunk-IYA4BFU2.js";
import {
  __esm,
  __export
} from "./chunk-J43GMYXM.js";

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/events/Event.js
function stopPropagation(evt) {
  evt.stopPropagation();
}
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      preventDefault() {
        this.defaultPrevented = true;
      }
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_Event();
    init_functions();
    init_obj();
    Target = class extends Disposable_default {
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : event;
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i = 0, ii = listeners.length; i < ii; ++i) {
          if ("handleEvent" in listeners[i]) {
            propagate = listeners[i].handleEvent(evt);
          } else {
            propagate = listeners[i].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      removeEventListener(type, listener) {
        const listeners = this.listeners_ && this.listeners_[type];
        if (listeners) {
          const index = listeners.indexOf(listener);
          if (index !== -1) {
            if (this.pendingRemovals_ && type in this.pendingRemovals_) {
              listeners[index] = VOID;
              ++this.pendingRemovals_[type];
            } else {
              listeners.splice(index, 1);
              if (listeners.length === 0) {
                delete this.listeners_[type];
              }
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      CHANGE: "change",
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/Observable.js
var Observable_exports = {};
__export(Observable_exports, {
  default: () => Observable_default,
  unByKey: () => unByKey
});
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(key);
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_Target();
    init_EventType();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = this.onInternal;
        this.once = this.onceInternal;
        this.un = this.unInternal;
        this.revision_ = 0;
      }
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      getRevision() {
        return this.revision_;
      }
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i = 0; i < len; ++i) {
            keys[i] = listen(this, type[i], listener);
          }
          return keys;
        } else {
          return listen(this, type, listener);
        }
      }
      onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
          const len = type.length;
          key = new Array(len);
          for (let i = 0; i < len; ++i) {
            key[i] = listenOnce(this, type[i], listener);
          }
        } else {
          key = listenOnce(this, type, listener);
        }
        listener.ol_key = key;
        return key;
      }
      unInternal(type, listener) {
        const key = listener.ol_key;
        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (let i = 0, ii = type.length; i < ii; ++i) {
            this.removeEventListener(type[i], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

export {
  stopPropagation,
  Event_default,
  init_Event,
  Disposable_default,
  init_Disposable,
  TRUE,
  FALSE,
  VOID,
  memoizeOne,
  toPromise,
  init_functions,
  Target_default,
  init_Target,
  EventType_default,
  init_EventType,
  listen,
  listenOnce,
  unlistenByKey,
  init_events,
  unByKey,
  Observable_default,
  Observable_exports,
  init_Observable
};
//# sourceMappingURL=chunk-PJ4BXDWN.js.map
